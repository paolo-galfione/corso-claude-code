# Screencast 4.1: Generazione del Piano di Lavoro

**Durata**: max 10 minuti
**Modulo**: 4 - L'Analista Funzionale
**Scopo**: Far generare a Claude un piano di refactoring strutturato in fasi

---

## SLIDE 1: Titolo

**Contenuto slide**:
```
GENERAZIONE DEL PIANO DI LAVORO

Dall'obiettivo alle fasi operative
```

**Testo da leggere**:
"Entriamo nel ruolo dell'Analista Funzionale. Il PO ha definito cosa fare e perché. L'Architetto ha preparato gli strumenti. L'Analista traduce tutto in un piano operativo strutturato in fasi."

---

## SLIDE 2: Il Ruolo dell'Analista

**Contenuto slide**:
```
L'ANALISTA FUNZIONALE

Flusso: Agente → Uomo

┌─────────────────────────────────────────┐
│                                         │
│   Claude genera il piano                │
│              │                          │
│              ▼                          │
│   Analista revisiona e integra          │
│              │                          │
│              ▼                          │
│   Piano finale per sviluppatori         │
│                                         │
└─────────────────────────────────────────┘

L'agente fa il lavoro pesante,
l'umano valida e raffina
```

**Testo da leggere**:
"L'Analista ha un flusso diverso dai ruoli precedenti. Claude genera la prima bozza del piano, l'Analista revisiona, integra con la sua conoscenza del dominio, e produce il piano finale. L'agente fa il lavoro pesante, l'umano aggiunge valore."

---

## SLIDE 3: Input per il Piano

**Contenuto slide**:
```
INPUT PER IL PIANO

Dal Product Owner:
└─ Obiettivi del refactoring
└─ Criteri di accettazione
└─ Vincoli e priorità

Dall'Architetto:
└─ Pattern architetturali (CLAUDE.md)
└─ Standard di codice
└─ Tool disponibili (commands, skills)

Dal Codice:
└─ Stato attuale del legacy
└─ Complessità reale
└─ Dipendenze
```

**Testo da leggere**:
"L'Analista raccoglie input da più fonti. Dal PO: cosa vogliamo ottenere. Dall'Architetto: come vogliamo farlo. Dal codice stesso: qual è la situazione reale. Claude può analizzare tutti questi input insieme."

---

## SLIDE 4: Plan Mode

**Contenuto slide**:
```
PLAN MODE

Comando: /plan "descrizione obiettivo"

Claude:
1. Analizza l'obiettivo
2. Esamina il codice esistente
3. Considera i vincoli (CLAUDE.md)
4. Propone piano strutturato
5. Attende approvazione

┌─────────────────────────────────────────┐
│  Il piano NON viene eseguito finché     │
│  l'umano non approva                    │
└─────────────────────────────────────────┘
```

**Testo da leggere**:
"Plan Mode è lo strumento chiave. Claude analizza, propone un piano strutturato, poi si ferma. Non esegue nulla finché l'Analista non approva. È il momento di revisione umana prima dell'azione."

---

## DEMO 1: Generare il Piano di Refactoring

**Cosa mostrare**:

1. Aprire Claude Code nel progetto
2. Usare Plan Mode:

```
/plan Voglio refactorare questo backend Express da monolitico
a architettura 3-tier. Il refactoring deve essere incrementale,
con ogni fase che produce un rilascio funzionante.
I test esistenti (che creeremo) devono passare dopo ogni fase.
```

3. Mostrare il piano generato da Claude:
   - Fase 0: Test baseline
   - Fase 1: Separazione tier
   - Fase 2: ORM
   - etc.

4. Per ogni fase Claude dovrebbe mostrare:
   - Obiettivo
   - File coinvolti
   - Criteri di completamento
   - Dipendenze

**Testo da leggere durante la demo**:
"Chiediamo a Claude di pianificare il refactoring completo. Guardate come struttura il piano in fasi, identifica i file coinvolti, definisce criteri di completamento. Tutto questo prima di scrivere una riga di codice."

---

## SLIDE 5: Fasi come Rilasci

**Contenuto slide**:
```
FASI = RILASCI

Ogni fase deve essere:

┌─────────────────────────────────────────┐
│  Autonoma                               │
│  └─ Completabile indipendentemente      │
│                                         │
│  Verificabile                           │
│  └─ Criteri oggettivi di completamento  │
│                                         │
│  Rilasciabile                           │
│  └─ Il sistema funziona dopo la fase    │
│                                         │
│  Rollbackabile                          │
│  └─ Possiamo tornare indietro se serve  │
└─────────────────────────────────────────┘
```

**Testo da leggere**:
"Ogni fase del piano deve essere un potenziale rilascio. Autonoma: si completa da sola. Verificabile: sappiamo quando è finita. Rilasciabile: il sistema funziona. Rollbackabile: possiamo tornare indietro. Se una fase non ha queste caratteristiche, va divisa."

---

## DEMO 2: Dettagliare una Fase

**Cosa mostrare**:

1. Prendere una fase del piano generato (es. Fase 1: Separazione tier)
2. Chiedere dettaglio:

```
Dettaglia la Fase 1 "Separazione 3-tier".
Per ogni endpoint (Customers, Orders, OrderDetails):
- Quali file creare
- Quali metodi spostare
- Quali test aggiungere
- In che ordine procedere
```

3. Claude produce piano dettagliato:
   - Ordine: prima Customers (più semplice), poi Orders, poi Details
   - Per ogni entità: route → service → repository
   - Test specifici per ogni passaggio

**Testo da leggere durante la demo**:
"Approfondiamo la Fase 1. Claude dettaglia l'ordine di lavoro: partire da Customers perché è la più semplice, poi Orders, poi Details. Per ognuna specifica file da creare, metodi da spostare, test da aggiungere."

---

## SLIDE 6: Il Piano Iterativo

**Contenuto slide**:
```
IL PIANO È ITERATIVO

Prima versione
    │
    ▼
Review analista
    │
    ▼
"Aggiungi X, modifica Y"
    │
    ▼
Versione aggiornata
    │
    ▼
Review...

Il piano evolve attraverso la conversazione
```

**Testo da leggere**:
"Il piano non nasce perfetto. L'Analista revisiona, chiede modifiche, Claude aggiorna. È un processo iterativo. Ogni passaggio raffina il piano finché non è pronto per essere eseguito."

---

## DEMO 3: Iterazione sul Piano

**Cosa mostrare**:

1. Identificare qualcosa da migliorare nel piano
2. Richiedere modifica:

```
Per la Fase 4 "Bug Fix", voglio che i bug siano
affrontati in ordine di criticità:
1. Prima i bug di sicurezza
2. Poi i bug logici che causano dati errati
3. Infine i bug di performance

Aggiorna il piano con questa prioritizzazione.
```

3. Claude aggiorna il piano mantenendo la struttura

**Testo da leggere durante la demo**:
"Chiediamo una modifica: prioritizzare i bug per criticità. Claude aggiorna il piano integrando la richiesta, senza perdere il lavoro fatto. L'Analista guida, Claude esegue le modifiche."

---

## SLIDE 7: Output dell'Analista

**Contenuto slide**:
```
OUTPUT DELL'ANALISTA

Documento piano con:

□ Overview del refactoring
□ Fasi con obiettivi chiari
□ Dettaglio per ogni fase:
  - File coinvolti
  - Ordine operazioni
  - Criteri completamento
  - Test richiesti
□ Dipendenze tra fasi
□ Rischi e mitigazioni
□ Stima effort (opzionale)

Questo documento guida gli sviluppatori/agenti
```

**Testo da leggere**:
"L'output dell'Analista è un documento completo che guida l'esecuzione. Overview, fasi dettagliate, criteri di completamento, dipendenze, rischi. Questo documento diventa l'input per gli sviluppatori e gli agenti che eseguiranno il lavoro."

---

## SLIDE 8: Best Practice

**Contenuto slide**:
```
BEST PRACTICE

✓ Iniziare con piano alto livello, poi dettagliare
✓ Ogni fase verificabile indipendentemente
✓ Iterare finché il piano è chiaro
✓ Validare con PO e Architetto prima di procedere
✓ Documentare assunzioni e decisioni

✗ Piano troppo dettagliato subito
✗ Fasi che dipendono da "tutto il resto"
✗ Ignorare vincoli del CLAUDE.md
✗ Procedere senza approvazione
```

**Testo da leggere**:
"Partite dal generale al particolare. Ogni fase deve essere verificabile da sola. Iterate finché il piano è cristallino. Validate con PO e Architetto. E non procedete mai senza approvazione esplicita."

---

## SLIDE 9: Takeaway

**Contenuto slide**:
```
TAKEAWAY

✓ L'Analista fa generare il piano a Claude
✓ Plan Mode struttura prima di eseguire
✓ Ogni fase = rilascio potenziale
✓ Iterazione raffina il piano
✓ Il piano guida sviluppatori e agenti

Prossimo screencast: Specifiche Operative per gli Agenti
```

**Testo da leggere**:
"L'Analista usa Claude per generare piani strutturati. Plan Mode garantisce che pensiamo prima di agire. Ogni fase è un rilascio. L'iterazione migliora il piano. Nel prossimo screencast vedremo come tradurre il piano in specifiche operative dettagliate."

---

## Note di Produzione

- La demo deve generare un piano REALE per il nostro backend
- Il piano generato sarà usato nei moduli successivi
- Mostrare l'iterazione: prima bozza → feedback → miglioramento
- Tempo: slide 4 min, demo 5 min, margine 1 min
