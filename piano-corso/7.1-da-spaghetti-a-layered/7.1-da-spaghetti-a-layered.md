# Screencast 7.1: Da Spaghetti a Layered Architecture

**Durata**: max 10 minuti
**Modulo**: 7 - Sviluppo Fase 2: Separazione 3-Tier
**Scopo**: Refactoring verso architettura a 3 livelli

---

## SLIDE 1: Titolo

**Contenuto slide**:
```
DA SPAGHETTI A LAYERED ARCHITECTURE

Separazione delle responsabilità
```

**Testo da leggere**:
"I test sono verdi. È il momento di separare il codice. Prendiamo il monolite e lo dividiamo in tre layer: API, Service, Repository. Ogni layer ha una responsabilità chiara."

---

## SLIDE 2: L'Architettura Target

**Contenuto slide**:
```
ARCHITETTURA TARGET

┌─────────────────────────────────────────┐
│           ROUTES (API Layer)            │
│  - Gestione HTTP request/response       │
│  - Validazione input                    │
│  - Nessuna logica di business           │
└─────────────────┬───────────────────────┘
                  │
┌─────────────────▼───────────────────────┐
│          SERVICES (Business Layer)      │
│  - Logica di business                   │
│  - Orchestrazione                       │
│  - Nessun accesso diretto a DB          │
└─────────────────┬───────────────────────┘
                  │
┌─────────────────▼───────────────────────┐
│        REPOSITORIES (Data Layer)        │
│  - Accesso al database                  │
│  - Query SQL/Knex                       │
│  - Nessuna logica di business           │
└─────────────────────────────────────────┘
```

**Testo da leggere**:
"Tre layer, tre responsabilità. Routes gestiscono HTTP. Services contengono la logica. Repositories parlano col database. Ogni layer conosce solo quello sotto di lui. Questa separazione rende il codice testabile, manutenibile, comprensibile."

---

## SLIDE 3: Il Codice Legacy

**Contenuto slide**:
```
IL CODICE LEGACY

app.get('/customers', (req, res) => {
  // Validazione
  const { city, country } = req.query;

  // Costruzione query (logica)
  let sql = 'SELECT * FROM Customers WHERE 1=1';
  if (city) sql += ` AND City = '${city}'`;
  if (country) sql += ` AND Country = '${country}'`;

  // Accesso DB
  db.all(sql, (err, rows) => {
    // Gestione risposta
    if (err) return res.status(500).json({error: err});
    res.json(rows);
  });
});

Tutto mischiato: HTTP + logica + DB
```

**Testo da leggere**:
"Ecco il codice legacy. Tutto in un handler: validazione, costruzione query, accesso database, risposta HTTP. Funziona, ma è impossibile testare la logica separatamente, riusare il codice, o capire dove mettere le mani."

---

## DEMO 1: Estrazione del Repository

**Cosa mostrare**:

1. Usare il command creato precedentemente o prompt diretto:

```
Estrai la logica di accesso al database per Customers
in un repository dedicato.

Crea /repositories/customerRepository.js con metodi:
- getAll(filters) - ritorna tutti i customers, applica filtri
- getById(id) - ritorna un customer per ID

Mantieni la stessa logica di filtro del legacy.
NON modificare ancora il route handler.
```

2. Claude crea il repository:

```javascript
// /repositories/customerRepository.js
class CustomerRepository {
  constructor(db) {
    this.db = db;
  }

  async getAll(filters = {}) {
    let query = this.db('Customers');
    if (filters.city) query = query.where('City', filters.city);
    if (filters.country) query = query.where('Country', filters.country);
    return query.select('*');
  }

  async getById(id) {
    return this.db('Customers').where('CustomerID', id).first();
  }
}
```

3. Mostrare che i test passano ancora (non abbiamo toccato il route)

**Testo da leggere durante la demo**:
"Estraiamo prima il repository. Claude crea la classe con i metodi che incapsulano le query. Nota: non abbiamo ancora modificato il route handler. I test passano ancora perché il sistema è invariato."

---

## SLIDE 4: Ordine di Estrazione

**Contenuto slide**:
```
ORDINE DI ESTRAZIONE

1. Repository (bottom-up)
   └─ Crea, ma non collegare ancora

2. Service
   └─ Crea, usa il repository

3. Route
   └─ Aggiorna per usare service

Ad ogni passo: esegui test

┌─────────────────────────────────────────┐
│  Perché bottom-up?                      │
│  Ogni layer dipende solo da quello      │
│  sotto, che esiste già                  │
└─────────────────────────────────────────┘
```

**Testo da leggere**:
"L'ordine è importante: bottom-up. Prima il repository, poi il service che lo usa, infine il route che usa il service. Ad ogni passo i test devono passare. Se qualcosa si rompe, sappiamo esattamente quale modifica l'ha causato."

---

## DEMO 2: Estrazione del Service

**Cosa mostrare**:

1. Prompt:

```
Crea /services/customerService.js che usa customerRepository.

Metodi:
- getAllCustomers(filters) - chiama repository.getAll
- getCustomerById(id) - chiama repository.getById

Per ora è un pass-through semplice, ma qui andrà
la logica di business quando la separeremo dal route.
```

2. Claude crea il service:

```javascript
// /services/customerService.js
class CustomerService {
  constructor(customerRepository) {
    this.repository = customerRepository;
  }

  async getAllCustomers(filters) {
    return this.repository.getAll(filters);
  }

  async getCustomerById(id) {
    const customer = await this.repository.getById(id);
    if (!customer) throw new Error('Customer not found');
    return customer;
  }
}
```

**Testo da leggere durante la demo**:
"Ora il service. Per adesso è semplice: chiama il repository. Ma nota la gestione errore: se il customer non esiste, lancia un'eccezione. Questa logica era nel route, ora è nel service dove appartiene."

---

## DEMO 3: Aggiornamento del Route

**Cosa mostrare**:

1. Prompt:

```
Aggiorna il route handler GET /customers per usare
customerService invece di accedere direttamente al DB.

Il route deve:
- Estrarre i filtri dalla query
- Chiamare service.getAllCustomers(filters)
- Gestire la risposta HTTP
- Gestire gli errori

NON deve contenere logica di business o query SQL.
```

2. Claude aggiorna il route:

```javascript
// routes/customerRoutes.js
router.get('/customers', async (req, res) => {
  try {
    const filters = {
      city: req.query.city,
      country: req.query.country
    };
    const customers = await customerService.getAllCustomers(filters);
    res.json(customers);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});
```

3. Eseguire i test: devono passare tutti

**Testo da leggere durante la demo**:
"Aggiorniamo il route. Ora è pulito: estrae parametri, chiama service, risponde. Nessuna query SQL, nessuna logica di business. Eseguiamo i test... tutti verdi! Il refactoring ha mantenuto il comportamento."

---

## SLIDE 5: Verifica del Refactoring

**Contenuto slide**:
```
VERIFICA DEL REFACTORING

✓ Test baseline passano
  └─ Comportamento API identico

✓ Nessuna query SQL in /routes
  └─ Verifica con grep

✓ Nessuna logica di business in /routes
  └─ Solo estrazione parametri e risposta HTTP

✓ Repository non conosce HTTP
  └─ Nessun req/res nel file

✓ Service non conosce HTTP né SQL diretto
  └─ Solo chiamate al repository
```

**Testo da leggere**:
"Come verifichiamo che il refactoring sia corretto? I test passano: comportamento identico. Possiamo fare grep per verificare che non ci siano query SQL nei routes. Ogni layer rispetta i suoi confini."

---

## SLIDE 6: Auto-Correzione in Azione

**Contenuto slide**:
```
AUTO-CORREZIONE IN AZIONE

Scenario:
1. Claude refactora
2. Test fallisce
3. Claude vede l'errore
4. Claude analizza la differenza
5. Claude corregge
6. Test passa

┌─────────────────────────────────────────┐
│  Questo è il loop agentico applicato    │
│  al refactoring                         │
└─────────────────────────────────────────┘
```

**Testo da leggere**:
"Se durante il refactoring un test fallisce, Claude vede l'errore, analizza cosa è cambiato, corregge. Il loop agentico in azione. I test baseline sono il feedback loop che permette l'auto-correzione."

---

## DEMO 4: Completare per Orders

**Cosa mostrare**:

1. Prompt:

```
Applica lo stesso refactoring 3-tier all'endpoint Orders.
Crea:
- /repositories/orderRepository.js
- /services/orderService.js
- /routes/orderRoutes.js

Mantieni la stessa struttura di Customers.
I test devono continuare a passare.
```

2. Claude esegue il refactoring completo
3. Se qualcosa fallisce, mostrare l'auto-correzione
4. Test finali tutti verdi

**Testo da leggere durante la demo**:
"Applichiamo lo stesso pattern a Orders. Claude segue la struttura stabilita: repository, service, route. È lo stesso processo, ripetibile per ogni entità."

---

## SLIDE 7: Struttura Risultante

**Contenuto slide**:
```
STRUTTURA RISULTANTE

/
├── routes/
│   ├── customerRoutes.js
│   ├── orderRoutes.js
│   └── orderDetailRoutes.js
├── services/
│   ├── customerService.js
│   ├── orderService.js
│   └── orderDetailService.js
├── repositories/
│   ├── customerRepository.js
│   ├── orderRepository.js
│   └── orderDetailRepository.js
└── tests/
    └── e2e/
        └── [test invariati]
```

**Testo da leggere**:
"Questa è la struttura finale della Fase 2. Tre cartelle, una per layer. Ogni entità ha il suo file in ogni layer. I test E2E sono invariati: verificano ancora lo stesso contratto API."

---

## SLIDE 8: Takeaway

**Contenuto slide**:
```
TAKEAWAY

✓ Separazione bottom-up: Repository → Service → Route
✓ Test ad ogni passo
✓ Ogni layer ha una sola responsabilità
✓ L'auto-correzione usa i test come feedback
✓ Pattern ripetibile per ogni entità

Prossimo modulo: Fase 3 - Introduzione ORM
```

**Testo da leggere**:
"La Fase 2 è completa. Abbiamo separato le responsabilità mantenendo il comportamento. I test ci hanno guidato e protetto. Nel prossimo modulo introduciamo Knex.js nei repository per query più pulite e sicure."

---

## Note di Produzione

- Il refactoring deve avvenire REALMENTE durante la demo
- Mostrare almeno un caso di test che fallisce e auto-correzione
- La struttura finale deve essere quella che useremo nelle fasi successive
- Tempo: slide 3 min, demo 6 min, margine 1 min
