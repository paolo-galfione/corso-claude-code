# Screencast 6.1: Identificazione e Fix dei Bug

**Durata**: max 10 minuti
**Modulo**: 6 - Sviluppo Fase 1: Bug Fixing
**Scopo**: Mostrare come Claude trova e corregge bug di diversi tipi sul codice legacy

---

## SLIDE 1: Titolo

**Contenuto slide**:
```
IDENTIFICAZIONE E FIX DEI BUG

Sicurezza, Logica, Performance
```

**Testo da leggere**:
"I test baseline sono verdi. Prima di refactorizzare, fissiamo i bug critici del codice legacy. Li affrontiamo in ordine di criticità: prima sicurezza, poi logici, infine performance. Claude li trova e li corregge sul codice esistente."

---

## SLIDE 2: Tipi di Bug nel Legacy

**Contenuto slide**:
```
TIPI DI BUG NEL LEGACY

┌─────────────────────────────────────────┐
│  SICUREZZA (Priorità 1)                 │
│  └─ SQL Injection                       │
│  └─ Validazione input mancante          │
│  └─ Esposizione dati sensibili          │
└─────────────────────────────────────────┘

┌─────────────────────────────────────────┐
│  LOGICI (Priorità 2)                    │
│  └─ Calcoli errati                      │
│  └─ Edge case non gestiti               │
│  └─ Filtri che non funzionano           │
└─────────────────────────────────────────┘

┌─────────────────────────────────────────┐
│  PERFORMANCE (Priorità 3)               │
│  └─ N+1 query                           │
│  └─ Query inefficienti                  │
│  └─ Caricamento dati inutili            │
└─────────────────────────────────────────┘
```

**Testo da leggere**:
"Tre categorie di bug. Sicurezza prima: sono i più critici. Poi logici: causano dati errati. Infine performance: il sistema funziona ma è lento. Questa priorità guida l'ordine di intervento."

---

## SLIDE 3: Workflow di Bug Fixing

**Contenuto slide**:
```
WORKFLOW DI BUG FIXING

1. Scrivi test che riproduce il bug
   └─ Il test deve FALLIRE

2. Verifica che il test fallisca
   └─ Conferma che il bug esiste

3. Implementa il fix
   └─ Cambia il codice

4. Verifica che il test passi
   └─ Il bug è fixato

5. Verifica che tutti i test passino
   └─ Non hai introdotto regressioni

"Red, Green, Refactor" applicato ai bug
```

**Testo da leggere**:
"Il workflow è sempre lo stesso. Prima il test che fallisce: dimostra il bug. Poi il fix. Poi verifica che il test passi. Poi verifica che gli altri test non siano regrediti. È il ciclo Red-Green applicato ai bug."

---

## DEMO 1: Bug di Sicurezza - SQL Injection

**Cosa mostrare**:

1. Prompt a Claude:

```
Analizza il codice legacy app.js e trova potenziali vulnerabilità
di SQL injection. Per ogni vulnerabilità:
1. Mostra il codice vulnerabile
2. Spiega come potrebbe essere sfruttato
3. Crea un test che dimostra la vulnerabilità
4. Implementa il fix usando prepared statements
5. Verifica che il test passi
```

2. Claude identifica (esempio):

```javascript
// VULNERABILE (codice legacy)
const sql = `SELECT * FROM Customers WHERE CompanyName LIKE '%${search}%'`;
db.all(sql, (err, rows) => { ... });

// EXPLOIT
// search = "'; DROP TABLE Customers; --"

// TEST
it('should not be vulnerable to SQL injection', async () => {
  const maliciousSearch = "'; DROP TABLE Customers; --";
  const response = await request(app)
    .get(`/customers?search=${encodeURIComponent(maliciousSearch)}`);

  // Non deve crashare o eseguire il drop
  expect(response.status).toBe(200);
  // Il database deve essere ancora intatto
  const check = await request(app).get('/customers');
  expect(check.body.length).toBeGreaterThan(0);
});
```

3. Claude implementa il fix con prepared statements:

```javascript
// FIX: Prepared statement con parametri
const sql = `SELECT * FROM Customers WHERE CompanyName LIKE ?`;
db.all(sql, [`%${search}%`], (err, rows) => { ... });
```

4. Il test passa

**Testo da leggere durante la demo**:
"Claude analizza il codice legacy cercando SQL injection. Trova la concatenazione diretta delle stringhe, crea un test che dimostra il problema, poi fixa usando prepared statements. Il parametro viene escaped automaticamente dal driver SQLite."

---

## SLIDE 4: Bug Logico

**Contenuto slide**:
```
BUG LOGICO: FILTRI CHE SI ESCLUDONO

Codice legacy:
if (city) sql += ` AND City = '${city}'`;
if (country) sql += ` AND City = '${country}'`; // BUG! Dovrebbe essere Country

Risultato:
GET /customers?city=London&country=UK
→ Cerca City='London' AND City='UK'
→ Zero risultati (nessuna città è sia London che UK)

Il bug passa inosservato se non si usano
entrambi i filtri insieme
```

**Testo da leggere**:
"Ecco un bug logico tipico: un copia-incolla sbagliato. Il filtro country applica City invece di Country. Funziona se usi un solo filtro, fallisce silenziosamente con entrambi. Difficile da trovare senza test specifici."

---

## DEMO 2: Bug Logico - Filtri

**Cosa mostrare**:

1. Prompt:

```
C'è un bug nei filtri dell'endpoint customers.
Quando si filtra per city E country insieme,
i risultati non sono corretti.

1. Crea un test che dimostra il bug
2. Identifica il problema nel codice
3. Fixa il bug
4. Verifica che il test passi
```

2. Claude crea il test:

```javascript
it('filters by city AND country correctly', async () => {
  const response = await request(app)
    .get('/customers?city=London&country=UK');

  expect(response.status).toBe(200);
  expect(response.body.length).toBeGreaterThan(0);

  // Tutti i risultati devono avere city=London E country=UK
  response.body.forEach(customer => {
    expect(customer.City).toBe('London');
    expect(customer.Country).toBe('UK');
  });
});
```

3. Claude trova il bug e lo fixa:

```javascript
// PRIMA (bug)
if (country) sql += ` AND City = '${country}'`;

// DOPO (fix)
if (country) sql += ` AND Country = ?`;
params.push(country);
```

4. Il test passa

**Testo da leggere durante la demo**:
"Il test verifica che entrambi i filtri siano applicati correttamente. Claude trova il bug: country filtra il campo sbagliato. Fix semplice, ma senza test sarebbe rimasto nascosto. Nota che Claude anche qui usa prepared statements."

---

## SLIDE 5: Bug di Performance - N+1

**Contenuto slide**:
```
BUG DI PERFORMANCE: N+1 QUERY

Codice problematico:
app.get('/orders', (req, res) => {
  db.all('SELECT * FROM Orders', (err, orders) => {
    orders.forEach(order => {
      db.get('SELECT CompanyName FROM Customers WHERE CustomerID = ?',
        [order.CustomerID], (err, customer) => {
          order.CustomerName = customer?.CompanyName;
        });
    });
    setTimeout(() => res.json(orders), 100);  // "Fix" con timeout...
  });
});

100 ordini = 1 query + 100 query = 101 query!
```

**Testo da leggere**:
"Il bug N+1 è classico. Per ogni ordine, una query separata per il customer. Con 100 ordini, 101 query invece di una sola. Il sistema funziona ma è lentissimo. E quel setTimeout è un hack orribile per aspettare le callback."

---

## DEMO 3: Bug Performance - N+1

**Cosa mostrare**:

1. Prompt:

```
Identifica e fixa il problema N+1 query in GET /orders.
Il codice fa una query per ogni ordine per recuperare il nome del customer.
Mostra:
1. Il codice problematico
2. Un test che verifica il risultato atteso
3. La soluzione ottimizzata con JOIN SQL
4. Verifica che il test passi
```

2. Claude implementa la soluzione:

```javascript
// PRIMA: N+1 query + setTimeout hack
app.get('/orders', (req, res) => {
  db.all('SELECT * FROM Orders', (err, orders) => {
    orders.forEach(order => {
      db.get('SELECT CompanyName FROM Customers WHERE CustomerID = ?',
        [order.CustomerID], (err, customer) => {
          order.CustomerName = customer?.CompanyName;
        });
    });
    setTimeout(() => res.json(orders), 100);
  });
});

// DOPO: 1 query con JOIN
app.get('/orders', (req, res) => {
  const sql = `
    SELECT Orders.*, Customers.CompanyName as CustomerName
    FROM Orders
    LEFT JOIN Customers ON Orders.CustomerID = Customers.CustomerID
  `;
  db.all(sql, (err, orders) => {
    if (err) return res.status(500).json({ error: err.message });
    res.json(orders);
  });
});
```

3. Mostrare che il test passa e il setTimeout è eliminato

**Testo da leggere durante la demo**:
"La soluzione è un JOIN SQL: una sola query invece di 101. Claude riscrive l'endpoint, elimina il setTimeout hack, i test verificano che il risultato sia identico. Performance e correttezza migliorate insieme."

---

## SLIDE 6: Auto-Correzione sui Bug

**Contenuto slide**:
```
AUTO-CORREZIONE SUI BUG

┌─────────────────────────────────────────┐
│  1. Claude scrive il fix                │
│  2. Esegue i test                       │
│  3. Un test fallisce                    │
│  4. Claude analizza il fallimento       │
│  5. Claude corregge il fix              │
│  6. Esegue di nuovo i test              │
│  7. Tutti verdi                         │
└─────────────────────────────────────────┘

Il loop agentico è particolarmente efficace
nel bug fixing: feedback immediato dai test
```

**Testo da leggere**:
"Il bug fixing è ideale per il loop agentico. Claude scrive il fix, i test danno feedback immediato. Se qualcosa non funziona, Claude vede l'errore e corregge. I test sono il loop di feedback perfetto."

---

## DEMO 4: Auto-Correzione in Azione

**Cosa mostrare**:

1. Introdurre intenzionalmente un bug fix incompleto
2. Mostrare Claude che:
   - Esegue i test
   - Vede il fallimento
   - Analizza il problema
   - Corregge
   - Ri-esegue e verifica

**Testo da leggere durante la demo**:
"Guardate l'auto-correzione. Il primo tentativo non è perfetto, un test fallisce. Claude vede l'errore, capisce cosa manca, corregge, riprova. Senza intervento umano, arriva alla soluzione corretta."

---

## SLIDE 7: Checklist Fase 1 - Bug Fix

**Contenuto slide**:
```
CHECKLIST FASE 1 - BUG FIX

Bug Sicurezza:
□ SQL Injection mitigata con prepared statements
□ Validazione input implementata
□ Dati sensibili non esposti

Bug Logici:
□ Filtri funzionano correttamente
□ Edge case gestiti (404 per ID non trovato)
□ Calcoli verificati

Bug Performance:
□ N+1 eliminati con JOIN
□ Query ottimizzate
□ setTimeout hack eliminati

□ Tutti i test E2E passano
```

**Testo da leggere**:
"Ecco la checklist della Fase 1. Ogni categoria di bug ha i suoi controlli. Alla fine, tutti i test devono passare. I bug sono fixati, il codice è ancora spaghetti ma più sicuro. Ora possiamo refactorizzare."

---

## SLIDE 8: Takeaway

**Contenuto slide**:
```
TAKEAWAY

✓ Bug in ordine di criticità: sicurezza → logica → performance
✓ Workflow: test che fallisce → fix → test che passa
✓ Prepared statements per SQL injection
✓ JOIN per risolvere N+1
✓ L'auto-correzione è efficace col feedback dei test
✓ Fix prima del refactoring: base solida

Prossimo modulo: Separazione 3-Tier
```

**Testo da leggere**:
"Il bug fixing con Claude è efficiente: lui trova e fixa, i test verificano. I prepared statements risolvono SQL injection, i JOIN risolvono N+1. Con i bug critici risolti, possiamo procedere con la separazione in architettura 3-tier."

---

## Note di Produzione

- I bug nel legacy devono esistere REALMENTE (vedi requisiti-spaghetti.md)
- Mostrare almeno un caso di auto-correzione
- I fix devono essere verificati dai test
- Evidenziare la priorità sicurezza > logica > performance
- Mostrare prepared statements esplicitamente (non ORM)
- Tempo: slide 3 min, demo 6 min, margine 1 min
