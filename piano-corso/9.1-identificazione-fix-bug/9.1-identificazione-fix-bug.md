# Screencast 9.1: Identificazione e Fix dei Bug

**Durata**: max 10 minuti
**Modulo**: 9 - Sviluppo Fase 4: Bug Fixing
**Scopo**: Mostrare come Claude trova e corregge bug di diversi tipi

---

## SLIDE 1: Titolo

**Contenuto slide**:
```
IDENTIFICAZIONE E FIX DEI BUG

Sicurezza, Logica, Performance
```

**Testo da leggere**:
"Il codice è refactored e testato. Ora affrontiamo i bug che esistevano nel legacy. Li fissiamo in ordine di criticità: prima sicurezza, poi logici, infine performance. Claude li trova e li corregge con la supervisione minima."

---

## SLIDE 2: Tipi di Bug nel Legacy

**Contenuto slide**:
```
TIPI DI BUG NEL LEGACY

┌─────────────────────────────────────────┐
│  SICUREZZA (Priorità 1)                 │
│  └─ SQL Injection                       │
│  └─ Validazione input mancante          │
│  └─ Esposizione dati sensibili          │
└─────────────────────────────────────────┘

┌─────────────────────────────────────────┐
│  LOGICI (Priorità 2)                    │
│  └─ Calcoli errati                      │
│  └─ Edge case non gestiti               │
│  └─ Filtri che non funzionano           │
└─────────────────────────────────────────┘

┌─────────────────────────────────────────┐
│  PERFORMANCE (Priorità 3)               │
│  └─ N+1 query                           │
│  └─ Query inefficienti                  │
│  └─ Caricamento dati inutili            │
└─────────────────────────────────────────┘
```

**Testo da leggere**:
"Tre categorie di bug. Sicurezza prima: sono i più critici. Poi logici: causano dati errati. Infine performance: il sistema funziona ma è lento. Questa priorità guida l'ordine di intervento."

---

## SLIDE 3: Workflow di Bug Fixing

**Contenuto slide**:
```
WORKFLOW DI BUG FIXING

1. Scrivi test che riproduce il bug
   └─ Il test deve FALLIRE

2. Verifica che il test fallisca
   └─ Conferma che il bug esiste

3. Implementa il fix
   └─ Cambia il codice

4. Verifica che il test passi
   └─ Il bug è fixato

5. Verifica che tutti i test passino
   └─ Non hai introdotto regressioni

"Red, Green, Refactor" applicato ai bug
```

**Testo da leggere**:
"Il workflow è sempre lo stesso. Prima il test che fallisce: dimostra il bug. Poi il fix. Poi verifica che il test passi. Poi verifica che gli altri test non siano regrediti. È il ciclo Red-Green applicato ai bug."

---

## DEMO 1: Bug di Sicurezza - SQL Injection

**Cosa mostrare**:

1. Prompt a Claude:

```
Analizza il codice e trova potenziali vulnerabilità
di SQL injection. Per ogni vulnerabilità:
1. Mostra il codice vulnerabile
2. Spiega come potrebbe essere sfruttato
3. Crea un test che dimostra la vulnerabilità
4. Implementa il fix
5. Verifica che il test passi
```

2. Claude identifica (esempio):

```javascript
// VULNERABILE (codice legacy - se ancora presente)
const sql = `SELECT * FROM Customers WHERE CustomerID = '${id}'`;

// EXPLOIT
// id = "'; DROP TABLE Customers; --"

// TEST
it('should not be vulnerable to SQL injection', async () => {
  const maliciousId = "'; DROP TABLE Customers; --";
  const response = await request(app)
    .get(`/customers/${encodeURIComponent(maliciousId)}`);

  // Non deve crashare o eseguire il drop
  expect(response.status).toBe(404); // Not found, non errore SQL
});
```

3. Claude mostra che con Knex il problema è già risolto
4. Se necessario, aggiunge validazione input

**Testo da leggere durante la demo**:
"Claude analizza il codice cercando SQL injection. Con Knex abbiamo già mitigato il rischio, ma aggiungiamo validazione input per un secondo livello di protezione. Il test verifica che input malevoli non causino problemi."

---

## SLIDE 4: Bug Logico

**Contenuto slide**:
```
BUG LOGICO: FILTRI CHE SI ESCLUDONO

Codice legacy:
if (city) query.where('City', city);
if (country) query.where('City', country); // BUG! Dovrebbe essere Country

Risultato:
GET /customers?city=London&country=UK
→ Cerca City='London' AND City='UK'
→ Zero risultati (nessuna città è sia London che UK)

Il bug passa inosservato se non si usano
entrambi i filtri insieme
```

**Testo da leggere**:
"Ecco un bug logico tipico: un copia-incolla sbagliato. Il filtro country applica City invece di Country. Funziona se usi un solo filtro, fallisce silenziosamente con entrambi. Difficile da trovare senza test specifici."

---

## DEMO 2: Bug Logico - Filtri

**Cosa mostrare**:

1. Prompt:

```
C'è un bug nei filtri dell'endpoint customers.
Quando si filtra per city E country insieme,
i risultati non sono corretti.

1. Crea un test che dimostra il bug
2. Identifica il problema nel codice
3. Fixa il bug
4. Verifica che il test passi
```

2. Claude crea il test:

```javascript
it('filters by city AND country correctly', async () => {
  const response = await request(app)
    .get('/customers?city=London&country=UK');

  expect(response.status).toBe(200);
  expect(response.body.length).toBeGreaterThan(0);

  // Tutti i risultati devono avere city=London E country=UK
  response.body.forEach(customer => {
    expect(customer.City).toBe('London');
    expect(customer.Country).toBe('UK');
  });
});
```

3. Claude trova e fixa il bug nel repository
4. Il test passa

**Testo da leggere durante la demo**:
"Il test verifica che entrambi i filtri siano applicati correttamente. Claude trova il bug nel repository: country filtra il campo sbagliato. Fix semplice, ma senza test sarebbe rimasto nascosto."

---

## SLIDE 5: Bug di Performance - N+1

**Contenuto slide**:
```
BUG DI PERFORMANCE: N+1 QUERY

Codice problematico:
async getOrdersWithCustomerName() {
  const orders = await knex('Orders').select('*');

  for (const order of orders) {
    const customer = await knex('Customers')
      .where('CustomerID', order.CustomerID)
      .first();
    order.CustomerName = customer.CompanyName;
  }

  return orders;
}

100 ordini = 1 query + 100 query = 101 query!
```

**Testo da leggere**:
"Il bug N+1 è classico. Per ogni ordine, una query separata per il customer. Con 100 ordini, 101 query invece di 2. Il sistema funziona ma è lentissimo. La soluzione: join o batch loading."

---

## DEMO 3: Bug Performance - N+1

**Cosa mostrare**:

1. Prompt:

```
Identifica e fixa il problema N+1 in getOrdersWithCustomerName.
Mostra:
1. Il codice problematico
2. Un test che misura il numero di query
3. La soluzione ottimizzata con JOIN
4. Verifica che il numero di query sia ridotto
```

2. Claude implementa la soluzione:

```javascript
// PRIMA: N+1 query
async getOrdersWithCustomerName() {
  const orders = await knex('Orders').select('*');
  for (const order of orders) {
    const customer = await knex('Customers')...
  }
}

// DOPO: 1 query con JOIN
async getOrdersWithCustomerName() {
  return knex('Orders')
    .join('Customers', 'Orders.CustomerID', 'Customers.CustomerID')
    .select('Orders.*', 'Customers.CompanyName as CustomerName');
}
```

3. Mostrare la differenza di performance (se possibile)

**Testo da leggere durante la demo**:
"La soluzione è un JOIN: una sola query invece di 101. Claude riscrive il metodo, i test verificano che il risultato sia identico. La performance migliora drasticamente senza cambiare il comportamento."

---

## SLIDE 6: Auto-Correzione sui Bug

**Contenuto slide**:
```
AUTO-CORREZIONE SUI BUG

┌─────────────────────────────────────────┐
│  1. Claude scrive il fix                │
│  2. Esegue i test                       │
│  3. Un test fallisce                    │
│  4. Claude analizza il fallimento       │
│  5. Claude corregge il fix              │
│  6. Esegue di nuovo i test              │
│  7. Tutti verdi                         │
└─────────────────────────────────────────┘

Il loop agentico è particolarmente efficace
nel bug fixing: feedback immediato dai test
```

**Testo da leggere**:
"Il bug fixing è ideale per il loop agentico. Claude scrive il fix, i test danno feedback immediato. Se qualcosa non funziona, Claude vede l'errore e corregge. I test sono il loop di feedback perfetto."

---

## DEMO 4: Auto-Correzione in Azione

**Cosa mostrare**:

1. Introdurre intenzionalmente un bug fix incompleto
2. Mostrare Claude che:
   - Esegue i test
   - Vede il fallimento
   - Analizza il problema
   - Corregge
   - Ri-esegue e verifica

**Testo da leggere durante la demo**:
"Guardate l'auto-correzione. Il primo tentativo non è perfetto, un test fallisce. Claude vede l'errore, capisce cosa manca, corregge, riprova. Senza intervento umano, arriva alla soluzione corretta."

---

## SLIDE 7: Checklist Fase 4

**Contenuto slide**:
```
CHECKLIST FASE 4

Bug Sicurezza:
□ SQL Injection mitigata
□ Validazione input implementata
□ Dati sensibili non esposti

Bug Logici:
□ Filtri funzionano correttamente
□ Edge case gestiti
□ Calcoli verificati

Bug Performance:
□ N+1 eliminati
□ Query ottimizzate
□ Indici verificati

□ Tutti i test (E2E + Unit) passano
```

**Testo da leggere**:
"Ecco la checklist della Fase 4. Ogni categoria di bug ha i suoi controlli. Alla fine, tutti i test devono passare. Se qualche test fallisce, il fix ha introdotto una regressione: bisogna investigare."

---

## SLIDE 8: Takeaway

**Contenuto slide**:
```
TAKEAWAY

✓ Bug in ordine di criticità: sicurezza → logica → performance
✓ Workflow: test che fallisce → fix → test che passa
✓ I test esistenti proteggono da regressioni
✓ L'auto-correzione è efficace col feedback dei test
✓ JOIN per risolvere N+1

Prossimo modulo: Fase 5 - Documentazione
```

**Testo da leggere**:
"Il bug fixing con Claude è efficiente: lui trova e fixa, i test verificano. Priorità alla sicurezza, poi logica, poi performance. Nel prossimo modulo completiamo con la documentazione automatica del codice."

---

## Note di Produzione

- I bug nel legacy devono esistere REALMENTE
- Mostrare almeno un caso di auto-correzione
- I fix devono essere verificati dai test
- Evidenziare la priorità sicurezza > logica > performance
- Tempo: slide 3 min, demo 6 min, margine 1 min
