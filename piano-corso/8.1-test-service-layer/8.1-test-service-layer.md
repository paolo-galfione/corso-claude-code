# Screencast 8.1: Test sui Service Layer

**Durata**: max 10 minuti
**Modulo**: 8 - Sviluppo Fase 3: Unit Testing
**Scopo**: Aggiungere unit test alla nuova architettura

---

## SLIDE 1: Titolo

**Contenuto slide**:
```
TEST SUI SERVICE LAYER

Testare la logica isolata
```

**Testo da leggere**:
"Abbiamo test E2E che verificano il comportamento API. Ora aggiungiamo unit test sui Service per testare la logica di business in isolamento. Test più veloci, più mirati, più facili da debuggare."

---

## SLIDE 2: Piramide dei Test

**Contenuto slide**:
```
PIRAMIDE DEI TEST

          /\
         /E2E\        Pochi, lenti, ampi
        /──────\
       /  Unit  \     Molti, veloci, mirati
      /──────────\

Abbiamo già:
└─ E2E (test baseline)

Aggiungiamo ora:
└─ Unit test sui Service
```

**Testo da leggere**:
"La piramide dei test: pochi E2E in cima, molti unit test alla base. Gli E2E verificano il sistema completo, gli unit test verificano i singoli componenti. Insieme danno copertura completa."

---

## SLIDE 3: Perché Unit Test sui Service

**Contenuto slide**:
```
PERCHÉ UNIT TEST SUI SERVICE

┌─────────────────────────────────────────┐
│  Velocità                               │
│  └─ Millisecondi invece di secondi      │
│                                         │
│  Isolamento                             │
│  └─ Testa solo la logica, non HTTP/DB   │
│                                         │
│  Debugging                              │
│  └─ Fallimento indica esattamente dove  │
│                                         │
│  Documentazione                         │
│  └─ I test spiegano cosa fa il service  │
└─────────────────────────────────────────┘
```

**Testo da leggere**:
"Gli unit test sui Service sono veloci, eseguono in millisecondi. Sono isolati: non serve database né server HTTP. Quando falliscono, sai esattamente quale metodo ha il problema. E documentano il comportamento atteso."

---

## SLIDE 4: Mocking del Repository

**Contenuto slide**:
```
MOCKING DEL REPOSITORY

Il Service dipende dal Repository.
Per testare il Service in isolamento,
mocckiamo il Repository.

┌─────────────────────────────────────────┐
│  Test E2E:                              │
│  HTTP → Route → Service → Repository → DB
│                                         │
│  Unit Test:                             │
│  Service → Mock Repository              │
│                                         │
│  Il mock simula il Repository           │
│  senza toccare il database              │
└─────────────────────────────────────────┘
```

**Testo da leggere**:
"Per isolare il Service, mocckiamo il Repository. Il mock simula le risposte del repository senza toccare il database. Così testiamo solo la logica del Service, non l'integrazione col DB."

---

## DEMO 1: Setup Unit Test

**Cosa mostrare**:

1. Chiedere a Claude di creare la struttura:

```
Crea la struttura per unit test sui Service.

- Directory /tests/unit
- File di setup con helper per mock
- Configurazione Jest per unit test separati da E2E
```

2. Claude crea:
   - `/tests/unit/setup.js`
   - Aggiorna `package.json` con script separati

```json
{
  "scripts": {
    "test": "jest",
    "test:e2e": "jest --testPathPattern=e2e",
    "test:unit": "jest --testPathPattern=unit"
  }
}
```

**Testo da leggere durante la demo**:
"Creiamo la struttura per unit test separata dagli E2E. Script separati permettono di eseguire solo i test unit durante lo sviluppo, più veloci, e la suite completa prima del commit."

---

## DEMO 2: Unit Test per CustomerService

**Cosa mostrare**:

1. Prompt:

```
Crea unit test per customerService.js.

Testa:
- getAllCustomers() ritorna i dati dal repository
- getAllCustomers(filters) passa i filtri al repository
- getCustomerById() con ID esistente
- getCustomerById() con ID non esistente lancia errore

Usa mock per il repository. Non deve esserci
accesso al database reale.
```

2. Claude crea i test:

```javascript
// /tests/unit/customerService.test.js
const CustomerService = require('../../services/customerService');

describe('CustomerService', () => {
  let service;
  let mockRepository;

  beforeEach(() => {
    mockRepository = {
      getAll: jest.fn(),
      getById: jest.fn()
    };
    service = new CustomerService(mockRepository);
  });

  describe('getAllCustomers', () => {
    it('returns all customers from repository', async () => {
      const mockCustomers = [{ CustomerID: 'ALFKI' }];
      mockRepository.getAll.mockResolvedValue(mockCustomers);

      const result = await service.getAllCustomers();

      expect(result).toEqual(mockCustomers);
      expect(mockRepository.getAll).toHaveBeenCalledWith({});
    });

    it('passes filters to repository', async () => {
      const filters = { city: 'London' };
      mockRepository.getAll.mockResolvedValue([]);

      await service.getAllCustomers(filters);

      expect(mockRepository.getAll).toHaveBeenCalledWith(filters);
    });
  });

  describe('getCustomerById', () => {
    it('throws error when customer not found', async () => {
      mockRepository.getById.mockResolvedValue(null);

      await expect(service.getCustomerById('INVALID'))
        .rejects.toThrow('Customer not found');
    });
  });
});
```

3. Eseguire: `npm run test:unit`

**Testo da leggere durante la demo**:
"Claude crea i test con mock del repository. Guardate: il mock è un oggetto con funzioni Jest che possiamo controllare. Testiamo cosa il service fa, non cosa fa il repository. I test passano in millisecondi."

---

## SLIDE 5: Test dei Casi Limite

**Contenuto slide**:
```
TEST DEI CASI LIMITE

Casi che gli E2E potrebbero non coprire:

┌─────────────────────────────────────────┐
│  Input nullo o undefined                │
│  └─ service.getCustomerById(null)       │
│                                         │
│  Errori del repository                  │
│  └─ mockRepository.getAll.mockRejected  │
│                                         │
│  Dati malformati                        │
│  └─ Repository ritorna dati incompleti  │
│                                         │
│  Boundary conditions                    │
│  └─ Lista vuota, singolo elemento       │
└─────────────────────────────────────────┘
```

**Testo da leggere**:
"Gli unit test permettono di testare casi limite che sarebbero difficili da riprodurre con E2E. Input nulli, errori del database, dati malformati. Questi test aumentano la robustezza del codice."

---

## DEMO 3: Test Casi Limite

**Cosa mostrare**:

1. Prompt:

```
Aggiungi test per casi limite in customerService:
- getCustomerById con id null
- getAllCustomers quando repository lancia errore
- Gestione di lista vuota
```

2. Claude aggiunge i test:

```javascript
describe('edge cases', () => {
  it('handles null id gracefully', async () => {
    await expect(service.getCustomerById(null))
      .rejects.toThrow();
  });

  it('propagates repository errors', async () => {
    mockRepository.getAll.mockRejectedValue(new Error('DB error'));

    await expect(service.getAllCustomers())
      .rejects.toThrow('DB error');
  });

  it('returns empty array when no customers', async () => {
    mockRepository.getAll.mockResolvedValue([]);

    const result = await service.getAllCustomers();

    expect(result).toEqual([]);
  });
});
```

3. Eseguire test e mostrare copertura

**Testo da leggere durante la demo**:
"Testiamo i casi limite. ID nullo, errore del database, lista vuota. Questi test documentano come il service si comporta in situazioni anomale. Se qualcuno modifica il codice, i test cattureranno regressioni."

---

## SLIDE 6: Copertura del Codice

**Contenuto slide**:
```
COPERTURA DEL CODICE

npm run test:unit -- --coverage

┌─────────────────────────────────────────┐
│  File                 │ % Stmts │ ...   │
│  services/            │         │       │
│   customerService.js  │   95%   │       │
│   orderService.js     │   92%   │       │
└─────────────────────────────────────────┘

Target: > 80% sui Service

Non ossessionarsi col 100%:
meglio buoni test all'80% che cattivi test al 100%
```

**Testo da leggere**:
"Jest genera report di copertura. Target realistico: oltre 80% sui Service. Non ossessionatevi col 100%: è meglio avere test significativi all'80% che test inutili per raggiungere il 100%."

---

## DEMO 4: Unit Test per OrderService

**Cosa mostrare**:

1. Prompt:

```
Crea unit test per orderService.js, inclusi
test per getOrderWithDetails che verifica
che il service combini correttamente ordine e dettagli.
```

2. Claude crea test che verificano la logica di aggregazione

3. Mostrare che i test sono veloci (< 1 secondo per tutti)

**Testo da leggere durante la demo**:
"Stessa strategia per OrderService. Notiamo il test per getOrderWithDetails: verifica che il service combini correttamente ordine e dettagli. Tutti i test unit eseguono in meno di un secondo."

---

## SLIDE 7: Unit Test vs E2E

**Contenuto slide**:
```
UNIT TEST VS E2E: QUANDO USARE COSA

Unit Test:
└─ Logica di business
└─ Trasformazioni dati
└─ Casi limite
└─ Sviluppo veloce (TDD)

E2E Test:
└─ Contratto API
└─ Integrazione completa
└─ Comportamento utente
└─ Verifica deploy

Usali ENTRAMBI, non uno o l'altro
```

**Testo da leggere**:
"Non è una scelta tra unit ed E2E. Servono entrambi. Unit per logica e casi limite, E2E per integrazione e contratto. Insieme danno una copertura completa e affidabile."

---

## SLIDE 8: Takeaway

**Contenuto slide**:
```
TAKEAWAY

✓ Unit test sui Service: veloci e mirati
✓ Mock del Repository per isolamento
✓ Testare casi limite
✓ Copertura > 80% come target
✓ Unit + E2E = copertura completa

Prossimo modulo: Fase 4 - Bug Fixing
```

**Testo da leggere**:
"Gli unit test completano la nostra suite di test. Veloci, mirati, isolati. Insieme agli E2E abbiamo copertura completa. Nel prossimo modulo usiamo questa rete di sicurezza per fixare i bug del codice legacy."

---

## Note di Produzione

- Mostrare la velocità degli unit test vs E2E
- Il mock deve essere chiaro e comprensibile
- Evidenziare come i test documentano il comportamento
- Report di copertura visibile
- Tempo: slide 3 min, demo 6 min, margine 1 min
