# Screencast 7.1: Migrazione a Knex.js

**Durata**: max 10 minuti
**Modulo**: 7 - Sviluppo Fase 2: Introduzione ORM
**Scopo**: Sostituire query SQL raw con query builder

---

## SLIDE 1: Titolo

**Contenuto slide**:
```
MIGRAZIONE A KNEX.JS

Query leggibili, sicure, manutenibili
```

**Testo da leggere**:
"La separazione 3-tier è completa. Ora miglioriamo il layer Repository sostituendo le query SQL raw con Knex.js. Query più leggibili, protezione da SQL injection, codice più manutenibile."

---

## SLIDE 2: Perché Knex.js

**Contenuto slide**:
```
PERCHÉ KNEX.JS

Prima (SQL raw):
let sql = 'SELECT * FROM Customers WHERE 1=1';
if (city) sql += ` AND City = '${city}'`;  // SQL injection!

Dopo (Knex.js):
const customers = await knex('Customers')
  .where('City', city)
  .select('*');  // Sicuro, leggibile

┌─────────────────────────────────────────┐
│  ✓ Query builder fluente                │
│  ✓ Parametri automaticamente escaped    │
│  ✓ Supporto per query complesse         │
│  ✓ Nessuna string concatenation         │
└─────────────────────────────────────────┘
```

**Testo da leggere**:
"Il codice legacy concatena stringhe SQL: funziona ma è vulnerabile a SQL injection. Knex.js è un query builder: costruisci query con metodi, i parametri sono escaped automaticamente. Stesso risultato, codice migliore."

---

## SLIDE 3: Strategia di Migrazione

**Contenuto slide**:
```
STRATEGIA DI MIGRAZIONE

1. Installare e configurare Knex
2. Migrare UN repository
3. Verificare con test
4. Ripetere per gli altri repository

┌─────────────────────────────────────────┐
│  Un repository alla volta               │
│  Test dopo ogni migrazione              │
│  Rollback facile se problemi            │
└─────────────────────────────────────────┘
```

**Testo da leggere**:
"Migriamo un repository alla volta. Dopo ogni migrazione verifichiamo con i test. Se qualcosa va storto, sappiamo esattamente quale modifica ha causato il problema e possiamo tornare indietro."

---

## DEMO 1: Setup Knex

**Cosa mostrare**:

1. Installazione:

```bash
npm install knex better-sqlite3
```

2. Chiedere a Claude di configurare:

```
Configura Knex.js per il progetto.
Crea:
- /config/database.js con la configurazione Knex per SQLite
- Inizializza la connessione al database northwind.db
- Esporta l'istanza knex configurata
```

3. Claude crea:

```javascript
// /config/database.js
const knex = require('knex')({
  client: 'better-sqlite3',
  connection: {
    filename: './database/northwind.db'
  },
  useNullAsDefault: true
});

module.exports = knex;
```

**Testo da leggere durante la demo**:
"Installiamo Knex e creiamo la configurazione. Claude genera il file di config che punta al nostro database SQLite. Questa istanza Knex verrà usata da tutti i repository."

---

## SLIDE 4: Query Knex Comuni

**Contenuto slide**:
```
QUERY KNEX COMUNI

// Select tutti
knex('Customers').select('*')

// Select con filtri
knex('Customers')
  .where('City', 'London')
  .where('Country', 'UK')
  .select('*')

// Select singolo
knex('Customers').where('CustomerID', id).first()

// Insert
knex('Customers').insert({ CustomerID: 'NEW01', ... })

// Update
knex('Customers').where('CustomerID', id).update({ City: 'Paris' })

// Delete
knex('Customers').where('CustomerID', id).del()
```

**Testo da leggere**:
"Ecco le query Knex più comuni. Select, filtri, singolo record, insert, update, delete. Sintassi fluente e leggibile. Ogni metodo restituisce una Promise che risolve al risultato."

---

## DEMO 2: Migrare CustomerRepository

**Cosa mostrare**:

1. Prompt:

```
Migra customerRepository.js da query SQL raw a Knex.js.

Requisiti:
- Importa l'istanza knex da /config/database.js
- Converti tutti i metodi per usare query Knex
- Mantieni la stessa interfaccia pubblica
- Gestisci i filtri opzionali in modo sicuro

I test devono continuare a passare.
```

2. Claude trasforma il repository:

```javascript
// repositories/customerRepository.js
const knex = require('../config/database');

class CustomerRepository {
  async getAll(filters = {}) {
    let query = knex('Customers');

    if (filters.city) {
      query = query.where('City', filters.city);
    }
    if (filters.country) {
      query = query.where('Country', filters.country);
    }

    return query.select('*');
  }

  async getById(id) {
    return knex('Customers')
      .where('CustomerID', id)
      .first();
  }

  async create(customerData) {
    const [id] = await knex('Customers')
      .insert(customerData);
    return this.getById(customerData.CustomerID);
  }

  // ... altri metodi
}
```

3. Eseguire test: devono passare

**Testo da leggere durante la demo**:
"Claude migra il repository a Knex. Guardate come i filtri opzionali sono gestiti: se presenti, aggiungiamo il where, altrimenti no. L'interfaccia pubblica non cambia. Eseguiamo i test... passano!"

---

## SLIDE 5: Gestione Relazioni

**Contenuto slide**:
```
GESTIONE RELAZIONI

Orders → OrderDetails

// Nel orderRepository
async getOrderWithDetails(orderId) {
  const order = await knex('Orders')
    .where('OrderID', orderId)
    .first();

  const details = await knex('OrderDetails')
    .where('OrderID', orderId)
    .select('*');

  return { ...order, details };
}

// Oppure con join
async getOrdersWithCustomer() {
  return knex('Orders')
    .join('Customers', 'Orders.CustomerID', 'Customers.CustomerID')
    .select('Orders.*', 'Customers.CompanyName');
}
```

**Testo da leggere**:
"Per le relazioni, due approcci. Query separate: prendi order, poi prendi details. Oppure join per combinare in una query. Knex supporta entrambi. Scegliete in base alle esigenze di performance."

---

## DEMO 3: Migrare OrderRepository con Relazioni

**Cosa mostrare**:

1. Prompt:

```
Migra orderRepository.js a Knex.js.

Attenzione speciale alle relazioni:
- Orders ha relazione con Customers (CustomerID)
- Orders ha relazione con OrderDetails (one-to-many)

Implementa getOrderWithDetails che ritorna l'ordine
con i suoi dettagli annidati.
```

2. Claude implementa gestendo le relazioni

3. Eseguire test specifici per Orders

**Testo da leggere durante la demo**:
"Migrando Orders, Claude gestisce le relazioni. Vediamo come implementa getOrderWithDetails: prima l'ordine, poi i dettagli, poi li combina. I test verificano che il comportamento sia identico."

---

## SLIDE 6: Vantaggi della Migrazione

**Contenuto slide**:
```
VANTAGGI DELLA MIGRAZIONE

✓ Sicurezza
  └─ Niente più SQL injection

✓ Leggibilità
  └─ Codice chiaro e manutenibile

✓ Manutenibilità
  └─ Facile modificare query

✓ Debugging
  └─ knex.toSQL() mostra la query generata

✓ Consistenza
  └─ Stessa sintassi per tutte le query
```

**Testo da leggere**:
"I vantaggi sono concreti. Sicurezza: SQL injection eliminata. Leggibilità: codice chiaro. Manutenibilità: modifiche facili. E per debugging, knex.toSQL() mostra la query SQL generata."

---

## DEMO 4: Debug con toSQL()

**Cosa mostrare**:

1. Prompt:

```
Mostrami come usare knex.toSQL() per debuggare
una query complessa con filtri multipli.
```

2. Claude dimostra:

```javascript
const query = knex('Customers')
  .where('City', 'London')
  .where('Country', 'UK')
  .select('*');

console.log(query.toSQL());
// { sql: 'select * from Customers where City = ? and Country = ?',
//   bindings: ['London', 'UK'] }
```

**Testo da leggere durante la demo**:
"Per debugging, toSQL() mostra la query generata con i bindings separati. Utile per capire cosa Knex sta eseguendo, specialmente con query complesse."

---

## SLIDE 7: Checklist Fase 2

**Contenuto slide**:
```
CHECKLIST FASE 2

□ Knex installato e configurato
□ CustomerRepository migrato
□ OrderRepository migrato
□ OrderDetailRepository migrato
□ Relazioni gestite correttamente
□ Tutti i test E2E passano
□ Niente più query SQL string concatenate

┌─────────────────────────────────────────┐
│  Se tutti i check sono verdi,           │
│  Fase 2 completata                      │
└─────────────────────────────────────────┘
```

**Testo da leggere**:
"Ecco la checklist della Fase 2. Knex configurato, tutti i repository migrati, relazioni gestite, test che passano. Quando tutto è verde, abbiamo completato la Fase 2."

---

## SLIDE 8: Takeaway

**Contenuto slide**:
```
TAKEAWAY

✓ Knex.js: query builder sicuro e leggibile
✓ Migrazione un repository alla volta
✓ Test dopo ogni migrazione
✓ Relazioni con query separate o join
✓ toSQL() per debugging

Prossimo modulo: Fase 3 - Unit Test
```

**Testo da leggere**:
"Knex rende il codice più sicuro e leggibile. Migriamo gradualmente, testiamo sempre. Nel prossimo modulo aggiungiamo unit test al layer Service per aumentare la copertura e la confidenza nel codice."

---

## Note di Produzione

- La migrazione deve avvenire REALMENTE durante la demo
- Mostrare la differenza tra codice prima e dopo
- Evidenziare il vantaggio di sicurezza (no SQL injection)
- I test devono passare alla fine di ogni migrazione
- Tempo: slide 3 min, demo 6 min, margine 1 min
