# Screencast 3.2: Custom Commands e Skills

**Durata**: max 10 minuti
**Modulo**: 3 - L'Architetto Software
**Scopo**: Automatizzare task ripetitivi specifici del progetto

---

## SLIDE 1: Titolo

**Contenuto slide**:
```
CUSTOM COMMANDS E SKILLS

Automazione per il team
```

**Testo da leggere**:
"Abbiamo configurato CLAUDE.md. Ora creiamo Custom Commands e Skills: strumenti che automatizzano task ripetitivi e garantiscono che tutti nel team lavorino nello stesso modo."

---

## SLIDE 2: Commands vs Skills

**Contenuto slide**:
```
COMMANDS VS SKILLS

┌─────────────────────────────────────────┐
│  COMMANDS                               │
│  └─ Azioni specifiche                   │
│  └─ "Fai questa cosa"                   │
│  └─ /new-endpoint                       │
│  └─ /run-tests                          │
└─────────────────────────────────────────┘

┌─────────────────────────────────────────┐
│  SKILLS                                 │
│  └─ Competenze riutilizzabili           │
│  └─ "Sai come fare questo tipo di cosa" │
│  └─ refactoring-patterns                │
│  └─ testing-strategies                  │
└─────────────────────────────────────────┘
```

**Testo da leggere**:
"Commands e Skills sono complementari. Un Command è un'azione: 'fai questo'. Una Skill è una competenza: 'sai fare questo tipo di cose'. I Commands usano le Skills per eseguire le azioni correttamente."

---

## SLIDE 3: Anatomia di un Command

**Contenuto slide**:
```
ANATOMIA DI UN COMMAND

.claude/commands/new-endpoint.md

┌─────────────────────────────────────────┐
│  # /new-endpoint                        │
│                                         │
│  Crea un nuovo endpoint REST seguendo   │
│  l'architettura 3-tier del progetto.    │
│                                         │
│  ## Input                               │
│  - $ENTITY: nome dell'entità            │
│  - $METHODS: metodi da implementare     │
│                                         │
│  ## Steps                               │
│  1. Crea route handler                  │
│  2. Crea service                        │
│  3. Crea/aggiorna repository            │
│  4. Aggiungi test                       │
│  5. Aggiorna OpenAPI                    │
└─────────────────────────────────────────┘
```

**Testo da leggere**:
"I Commands vivono in .claude/commands. Ogni command è un file markdown con nome, descrizione, input attesi e passi da eseguire. Quando invochiamo /new-endpoint, Claude legge questo file e sa esattamente cosa fare."

---

## DEMO 1: Creare un Command

**Cosa mostrare**:

1. Creare la struttura: `mkdir -p .claude/commands`
2. Creare il file `.claude/commands/new-endpoint.md`:

```markdown
# /new-endpoint

Crea un nuovo endpoint REST completo per un'entità.

## Argomenti
- `$ENTITY`: Nome dell'entità (es. "customer", "order")
- `$METHODS`: Metodi da implementare (default: "getAll,getById,create,update,delete")

## Procedura

1. **Route Handler** (`/routes/${ENTITY}Routes.js`)
   - Crea il file se non esiste
   - Implementa i route handler per ogni metodo
   - Aggiungi validazione input

2. **Service** (`/services/${ENTITY}Service.js`)
   - Crea il file se non esiste
   - Implementa la logica di business

3. **Repository** (`/repositories/${ENTITY}Repository.js`)
   - Crea il file se non esiste
   - Implementa query Knex.js

4. **Test**
   - Crea test E2E in `/tests/e2e/${ENTITY}.test.js`
   - Crea unit test in `/tests/unit/${ENTITY}Service.test.js`

5. **Documentazione**
   - Aggiorna `/docs/openapi.yaml` con i nuovi endpoint

6. **Verifica**
   - Esegui `npm test` e verifica che passi
```

3. Testare il command: `/new-endpoint customer`

**Testo da leggere durante la demo**:
"Creiamo un command per nuovi endpoint. Definiamo gli argomenti, poi i passi in dettaglio. Ora quando qualcuno invoca /new-endpoint, Claude segue esattamente questa procedura."

---

## SLIDE 4: Commands Utili per il Refactoring

**Contenuto slide**:
```
COMMANDS PER IL NOSTRO PROGETTO

/extract-service $FILE
└─ Estrae la logica di business in un service

/extract-repository $FILE
└─ Estrae le query in un repository

/add-tests $FILE
└─ Aggiunge test per un file esistente

/fix-bug $DESCRIPTION
└─ Workflow: test → fix → verify

/document $FILE
└─ Genera JSDoc per un file
```

**Testo da leggere**:
"Per il nostro refactoring, questi commands saranno utili. Estrarre service, estrarre repository, aggiungere test, fixare bug, documentare. Ogni command standardizza un workflow che altrimenti dovremmo spiegare ogni volta."

---

## DEMO 2: Command per Estrazione Service

**Cosa mostrare**:

1. Creare `.claude/commands/extract-service.md`:

```markdown
# /extract-service

Estrae la logica di business da un file in un Service dedicato.

## Argomenti
- `$FILE`: File da cui estrarre (es. "/routes/orders.js")

## Procedura

1. **Analisi**
   - Leggi il file $FILE
   - Identifica la logica di business (non routing, non validazione)

2. **Creazione Service**
   - Determina il nome dell'entità dal file
   - Crea `/services/${entity}Service.js`
   - Sposta la logica identificata nel service
   - Esporta i metodi necessari

3. **Aggiornamento Originale**
   - Nel file originale, importa il service
   - Sostituisci la logica inline con chiamate al service

4. **Test**
   - I test esistenti devono continuare a passare
   - Se falliscono, verifica che la logica sia stata spostata correttamente

5. **Verifica Finale**
   - Nessuna logica di business rimasta in $FILE
   - Service contiene solo logica, no routing
```

2. Mostrare brevemente come funzionerebbe

**Testo da leggere durante la demo**:
"Questo command guida l'estrazione di un service. Claude analizza, crea il service, aggiorna il file originale, verifica i test. Il workflow è lo stesso ogni volta, per ogni file."

---

## SLIDE 5: Skills

**Contenuto slide**:
```
SKILLS: COMPETENZE RIUTILIZZABILI

.claude/skills/3tier-refactoring.md

┌─────────────────────────────────────────┐
│  # Skill: Refactoring 3-Tier            │
│                                         │
│  ## Cosa so fare                        │
│  - Identificare responsabilità          │
│  - Separare layer correttamente         │
│  - Mantenere compatibilità API          │
│                                         │
│  ## Pattern che uso                     │
│  - Route → Service → Repository         │
│  - Dependency Injection base            │
│  - Error handling consistente           │
│                                         │
│  ## Errori da evitare                   │
│  - Circular dependencies                │
│  - Leaky abstractions                   │
│  - Over-engineering                     │
└─────────────────────────────────────────┘
```

**Testo da leggere**:
"Le Skills sono conoscenze, non azioni. Questa skill spiega cosa significa fare refactoring 3-tier: quali pattern usare, quali errori evitare. I commands possono riferirsi a questa skill per applicare queste conoscenze."

---

## DEMO 3: Creare una Skill

**Cosa mostrare**:

1. Creare `mkdir -p .claude/skills`
2. Creare `.claude/skills/knex-patterns.md`:

```markdown
# Skill: Knex.js Patterns

## Contesto
Questa skill definisce come usare Knex.js nel progetto.

## Query Patterns

### Select con filtri
```javascript
const results = await knex('table')
  .where(filters)
  .orderBy('column')
  .select('*');
```

### Insert con ritorno ID
```javascript
const [id] = await knex('table')
  .insert(data)
  .returning('id');
```

### Transaction
```javascript
await knex.transaction(async (trx) => {
  await trx('table1').insert(data1);
  await trx('table2').insert(data2);
});
```

## Errori Comuni da Evitare
- Non dimenticare `await` sulle query
- Usare sempre parametrizzazione (no string concatenation)
- Chiudere le connessioni in caso di errore

## Convenzioni Progetto
- Un repository per entità
- Metodi standard: getAll, getById, create, update, delete
- Filtri passati come oggetto, non parametri singoli
```

**Testo da leggere durante la demo**:
"Questa skill insegna a Claude come usare Knex nel nostro progetto. Pattern da seguire, errori da evitare, convenzioni. Quando lavora con Knex, applicherà automaticamente queste conoscenze."

---

## SLIDE 6: Distribuzione al Team

**Contenuto slide**:
```
DISTRIBUZIONE AL TEAM

Opzione 1: Repository condiviso
└─ .claude/ versionato con il progetto
└─ Tutti hanno gli stessi commands/skills

Opzione 2: Pacchetto npm
└─ @team/claude-config
└─ npm install --save-dev
└─ Aggiornamenti centralizzati

Opzione 3: Git submodule
└─ Repository dedicato per config Claude
└─ Condiviso tra più progetti
```

**Testo da leggere**:
"Come distribuire commands e skills al team? L'opzione più semplice: versionateli con il progetto. Tutti fanno pull e hanno la stessa configurazione. Per condividere tra più progetti, usate un pacchetto npm o un submodule."

---

## SLIDE 7: Best Practice

**Contenuto slide**:
```
BEST PRACTICE

✓ Nomi commands chiari e descrittivi
✓ Documentare gli argomenti attesi
✓ Includere verifica finale nei commands
✓ Skills focalizzate su un dominio
✓ Testare commands prima di distribuire

✗ Commands troppo generici
✗ Duplicare logica tra commands
✗ Skills che sono liste di comandi
✗ Dimenticare edge cases
```

**Testo da leggere**:
"Commands con nomi chiari, argomenti documentati, verifica finale inclusa. Skills focalizzate, non generiche. Testate sempre i commands prima di condividerli col team. Un command rotto è peggio di nessun command."

---

## SLIDE 8: Takeaway

**Contenuto slide**:
```
TAKEAWAY

✓ Commands = azioni standardizzate
✓ Skills = competenze riutilizzabili
✓ Creano consistenza nel team
✓ Riducono errori ripetitivi
✓ Si distribuiscono facilmente

Prossimo screencast: Hooks per l'Automazione
```

**Testo da leggere**:
"Commands e Skills standardizzano il lavoro del team. Tutti seguono gli stessi pattern, fanno gli stessi controlli, evitano gli stessi errori. Nel prossimo screencast vedremo gli Hooks: trigger automatici che garantiscono qualità senza intervento manuale."

---

## Note di Produzione

- Creare commands REALI che useremo nel refactoring
- La demo deve mostrare un command che funziona davvero
- I file creati restano nel progetto per i screencast successivi
- Tempo: slide 4 min, demo 5 min, margine 1 min
