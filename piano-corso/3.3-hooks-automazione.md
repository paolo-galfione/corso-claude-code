# Screencast 3.3: Hooks per l'Automazione

**Durata**: max 10 minuti
**Modulo**: 3 - L'Architetto Software
**Scopo**: Configurare trigger automatici per garantire qualità

---

## SLIDE 1: Titolo

**Contenuto slide**:
```
HOOKS PER L'AUTOMAZIONE

Qualità garantita, intervento zero
```

**Testo da leggere**:
"Commands e Skills automatizzano le azioni. Gli Hooks automatizzano i controlli. Sono trigger che scattano su eventi specifici, garantendo che certe verifiche avvengano sempre, senza doverci pensare."

---

## SLIDE 2: Cosa Sono gli Hooks

**Contenuto slide**:
```
COSA SONO GLI HOOKS

Trigger automatici su eventi Claude Code

┌─────────────────────────────────────────┐
│  EVENTO          →    AZIONE            │
├─────────────────────────────────────────┤
│  Pre-commit      →    Esegui test       │
│  Post-edit       →    Formatta codice   │
│  On-error        →    Log dettagliato   │
│  Pre-push        →    Verifica build    │
└─────────────────────────────────────────┘

Se l'azione fallisce, l'operazione si blocca
```

**Testo da leggere**:
"Un hook è: quando succede X, fai Y. Se Y fallisce, blocca l'operazione. Questo garantisce che certe condizioni siano sempre verificate. Non potete fare commit se i test falliscono. Non potete pushare se la build è rotta."

---

## SLIDE 3: Tipi di Hooks

**Contenuto slide**:
```
TIPI DI HOOKS

PreToolCall
└─ Prima che Claude esegua un tool
└─ Es: verifica permessi, log azione

PostToolCall
└─ Dopo che Claude ha eseguito un tool
└─ Es: formattazione, validazione output

Notification
└─ Eventi informativi
└─ Es: log, metriche, alert

Stop
└─ Termina l'esecuzione se condizione vera
└─ Es: troppi errori, file proibito modificato
```

**Testo da leggere**:
"Ci sono diversi tipi di hooks. Pre e Post per azioni prima e dopo i tool. Notification per logging e alert. Stop per bloccare l'esecuzione in casi critici. Ogni tipo ha il suo uso specifico."

---

## SLIDE 4: Configurazione Hooks

**Contenuto slide**:
```
CONFIGURAZIONE

.claude/settings.json

{
  "hooks": {
    "PreToolCall": [
      {
        "matcher": "Write|Edit",
        "command": "echo 'Modifica file: $FILE'"
      }
    ],
    "PostToolCall": [
      {
        "matcher": "Write|Edit",
        "command": "npm run lint:fix $FILE"
      }
    ]
  }
}
```

**Testo da leggere**:
"Gli hooks si configurano in settings.json. Ogni hook ha un matcher che specifica su quali tool scatta, e un command che viene eseguito. Nell'esempio: prima di scrivere logghiamo, dopo formattiamo automaticamente."

---

## DEMO 1: Hook Post-Edit per Linting

**Cosa mostrare**:

1. Creare/modificare `.claude/settings.json`:

```json
{
  "hooks": {
    "PostToolCall": [
      {
        "matcher": "Write|Edit",
        "command": "npx eslint --fix \"$CLAUDE_FILE_PATH\" 2>/dev/null || true"
      }
    ]
  }
}
```

2. Far modificare un file a Claude con formattazione non perfetta
3. Mostrare che il file viene formattato automaticamente dopo la modifica

**Testo da leggere durante la demo**:
"Configuriamo un hook che formatta automaticamente ogni file modificato. Claude scrive, l'hook scatta, il linter sistema. Il codice è sempre formattato correttamente senza doverci pensare."

---

## SLIDE 5: Hook per Test Automatici

**Contenuto slide**:
```
HOOK PER TEST AUTOMATICI

Dopo ogni modifica a file .js in /routes, /services, /repositories:
esegui i test correlati

{
  "PostToolCall": [
    {
      "matcher": "Write|Edit",
      "command": "./scripts/run-related-tests.sh $FILE"
    }
  ]
}

Script run-related-tests.sh:
- Identifica test correlati al file
- Esegue solo quei test
- Feedback rapido senza full suite
```

**Testo da leggere**:
"Questo hook esegue test correlati dopo ogni modifica. Non la full suite, solo i test rilevanti. Feedback rapido: se hai rotto qualcosa, lo sai subito. L'agente può correggere prima di procedere."

---

## DEMO 2: Hook con Validazione

**Cosa mostrare**:

1. Aggiungere hook che blocca modifiche a file protetti:

```json
{
  "hooks": {
    "PreToolCall": [
      {
        "matcher": "Write|Edit",
        "command": "node ./scripts/check-protected-files.js \"$CLAUDE_FILE_PATH\""
      }
    ]
  }
}
```

2. Creare lo script `scripts/check-protected-files.js`:

```javascript
const protectedPaths = [
  '/config/production.json',
  '/migrations/',
  '/.env'
];

const file = process.argv[2];
const isProtected = protectedPaths.some(p => file.includes(p));

if (isProtected) {
  console.error(`BLOCCATO: ${file} è un file protetto`);
  process.exit(1);
}
```

3. Provare a far modificare un file protetto a Claude
4. Mostrare che l'operazione viene bloccata

**Testo da leggere durante la demo**:
"Questo hook protegge file sensibili. Se Claude prova a modificare un file in /config/production o /migrations, l'hook blocca. È una regola del CLAUDE.md, ma enforced automaticamente."

---

## SLIDE 6: Pattern Comuni

**Contenuto slide**:
```
PATTERN COMUNI

Qualità codice
└─ Post-edit: lint, format, type-check

Sicurezza
└─ Pre-write: check file protetti
└─ Pre-write: scan secrets

Testing
└─ Post-edit: test correlati
└─ Pre-commit: full test suite

Logging
└─ Pre/Post: audit trail modifiche
└─ On-error: log dettagliato per debug
```

**Testo da leggere**:
"Questi sono pattern comuni. Qualità: formattazione automatica. Sicurezza: protezione file e scan secrets. Testing: verifica continua. Logging: traccia delle modifiche. Scegliete quelli utili per il vostro progetto."

---

## SLIDE 7: Hooks e Auto-Correzione

**Contenuto slide**:
```
HOOKS E AUTO-CORREZIONE

Hook fallisce → Claude riceve errore → Corregge

┌─────────────────────────────────────────┐
│  1. Claude modifica file                │
│  2. Hook lint fallisce                  │
│  3. Claude vede errore ESLint           │
│  4. Claude corregge il problema         │
│  5. Hook passa                          │
│  6. Operazione completa                 │
└─────────────────────────────────────────┘

Il loop agentico include gli hooks
```

**Testo da leggere**:
"Quando un hook fallisce, Claude vede l'errore e può correggerlo. Non è un blocco definitivo, è feedback nel loop agentico. Claude scrive codice con errore di lint, l'hook segnala, Claude corregge, l'hook passa. Automazione e auto-correzione insieme."

---

## DEMO 3: Hook che Innesca Auto-Correzione

**Cosa mostrare**:

1. Far scrivere a Claude codice con un problema di lint intenzionale
2. L'hook di lint fallisce
3. Claude vede l'errore
4. Claude corregge
5. L'hook passa

**Testo da leggere durante la demo**:
"Guardate il loop in azione. Claude scrive codice, l'hook trova un problema, Claude lo vede, corregge, riprova. L'hook garantisce la qualità, l'agente fa il lavoro. Supervisione automatica."

---

## SLIDE 8: Best Practice

**Contenuto slide**:
```
BEST PRACTICE

✓ Hooks veloci (< 5 secondi ideale)
✓ Messaggi di errore chiari
✓ Fail fast: blocca subito se critico
✓ Log per debugging
✓ Test degli hooks stessi

✗ Hooks che richiedono minuti
✗ Errori criptici
✗ Troppi hooks sovrapposti
✗ Hooks che modificano silenziosamente
```

**Testo da leggere**:
"Gli hooks devono essere veloci, altrimenti rallentano il flusso. Messaggi chiari così Claude capisce cosa correggere. Non sovrapponete troppi hooks. E testate gli hooks: un hook rotto blocca tutto il lavoro."

---

## SLIDE 9: Takeaway

**Contenuto slide**:
```
TAKEAWAY

✓ Hooks = trigger automatici su eventi
✓ Garantiscono qualità senza intervento
✓ Si integrano nel loop agentico
✓ Proteggono da errori comuni
✓ Devono essere veloci e chiari

Prossimo screencast: MCP Servers
```

**Testo da leggere**:
"Gli hooks completano l'automazione. Commands definiscono come fare le cose, hooks verificano che siano fatte bene. Insieme creano un ambiente dove la qualità è automatica. Nel prossimo screencast esploriamo gli MCP Servers: estensioni che ampliano le capacità di Claude."

---

## Note di Produzione

- Preparare script reali che funzionano
- La demo dell'auto-correzione è cruciale: mostra il loop agentico
- Non sovraccaricare: 2-3 hooks dimostrativi bastano
- Tempo: slide 4 min, demo 5 min, margine 1 min
