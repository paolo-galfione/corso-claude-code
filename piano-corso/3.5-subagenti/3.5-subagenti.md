# Screencast 3.5: Subagenti

**Durata**: max 10 minuti
**Modulo**: 3 - L'Architetto Software
**Scopo**: Comprendere il ruolo dei subagenti per gestire contesto e specializzazione

---

## SLIDE 1: Titolo

**Contenuto slide**:
```
SUBAGENTI

Divide et impera per compiti complessi
```

**Testo da leggere**:
"Finora abbiamo lavorato con un singolo agente. Ma quando i task diventano complessi e toccano domini diversi, il contesto si satura. I subagenti risolvono questo problema: agenti specializzati che lavorano su compiti specifici."

---

## SLIDE 2: Il Problema del Contesto

**Contenuto slide**:
```
IL PROBLEMA DEL CONTESTO

Un agente che fa tutto:

┌─────────────────────────────────────────┐
│  Contesto dell'agente principale        │
│                                         │
│  - Architettura del progetto            │
│  - Dettagli dei test E2E                │
│  - Sintassi Knex.js                     │
│  - Pattern di refactoring               │
│  - Convenzioni JSDoc                    │
│  - Bug da fixare                        │
│  - Specifiche OpenAPI                   │
│  - ...                                  │
│                                         │
│  → Contesto saturo, risposte degradate  │
└─────────────────────────────────────────┘
```

**Testo da leggere**:
"Quando un agente gestisce tutto, il suo contesto si riempie di informazioni eterogenee: architettura, test, ORM, documentazione. Più il contesto cresce, più l'agente fatica a mantenere il focus. Le risposte degradano, perde dettagli importanti."

---

## SLIDE 3: La Soluzione: Subagenti

**Contenuto slide**:
```
LA SOLUZIONE: SUBAGENTI

┌─────────────────────────────────────────┐
│         Agente Principale               │
│         (Coordinatore)                  │
│                                         │
│    "Devo refactorare e testare"         │
└───────────────┬─────────────────────────┘
                │
        ┌───────┴───────┐
        │               │
        ▼               ▼
┌───────────────┐ ┌───────────────┐
│  Refactoring  │ │     Test      │
│    Agent      │ │    Agent      │
│               │ │               │
│ Solo pattern  │ │ Solo test,    │
│ e struttura   │ │ assertion,    │
│ codice        │ │ coverage      │
└───────────────┘ └───────────────┘

Contesti separati, specializzati
```

**Testo da leggere**:
"Con i subagenti, l'agente principale diventa coordinatore. Delega task specifici a subagenti specializzati. Ogni subagente ha il suo contesto pulito, focalizzato su un solo dominio. Niente interferenze, massima efficacia."

---

## SLIDE 4: Vantaggi dei Subagenti

**Contenuto slide**:
```
VANTAGGI DEI SUBAGENTI

1. Contesto Pulito
   └─ Ogni agente vede solo ciò che serve

2. Specializzazione
   └─ Prompt e skill ottimizzati per dominio

3. Parallelizzazione
   └─ Più subagenti lavorano contemporaneamente

4. Isolamento Errori
   └─ Un errore in un subagente non corrompe gli altri

5. Riusabilità
   └─ Stesso subagente per task simili
```

**Testo da leggere**:
"I vantaggi sono concreti. Contesto pulito: ogni agente è focalizzato. Specializzazione: prompt ottimizzati. Parallelizzazione: lavoro simultaneo. Isolamento: errori contenuti. Riusabilità: configurazione una volta, uso multiplo."

---

## SLIDE 5: Subagenti Espliciti vs Impliciti

**Contenuto slide**:
```
SUBAGENTI ESPLICITI VS IMPLICITI

ESPLICITO
L'utente/agente principale invoca il subagente

"Usa il Test Agent per creare i test baseline"
└─ Controllo diretto su quando e come

IMPLICITO
Claude Code spawna subagenti automaticamente

"Refactora questo file"
└─ Claude decide autonomamente di usare
   subagenti per analisi, modifica, verifica

┌─────────────────────────────────────────┐
│  In entrambi i casi: supervisione       │
│  dell'agente principale sui risultati   │
└─────────────────────────────────────────┘
```

**Testo da leggere**:
"I subagenti possono essere espliciti o impliciti. Esplicito: voi o l'agente principale decidete di invocare un subagente specifico. Implicito: Claude Code decide autonomamente di usare subagenti per completare un task complesso. In entrambi i casi, l'agente principale supervisiona i risultati."

---

## SLIDE 6: Subagenti nel Nostro Corso

**Contenuto slide**:
```
SUBAGENTI NEL NOSTRO CORSO

┌──────────────────┬────────────────────────┐
│  Subagente       │  Quando usarlo         │
├──────────────────┼────────────────────────┤
│  Test Agent      │  Fase 0: test baseline │
│                  │  Fase 4: unit test     │
├──────────────────┼────────────────────────┤
│  Bug Fix Agent   │  Fase 1: sicurezza,    │
│                  │  logica, performance   │
├──────────────────┼────────────────────────┤
│  Refactoring     │  Fase 2: separazione   │
│  Agent           │  Fase 3: migrazione    │
├──────────────────┼────────────────────────┤
│  Documentation   │  Fase 5: JSDoc/OpenAPI │
│  Agent           │                        │
├──────────────────┼────────────────────────┤
│  Code Review     │  Dopo ogni fase        │
│  Agent           │  (qualità e security)  │
└──────────────────┴────────────────────────┘
```

**Testo da leggere**:
"Nel nostro corso useremo diversi subagenti. Test Agent per creare test. Bug Fix Agent per sicurezza e performance. Refactoring Agent per la separazione dei layer. Documentation Agent per JSDoc e OpenAPI. Code Review Agent per verificare qualità dopo ogni fase."

---

## DEMO 1: Invocazione Esplicita di un Subagente

**Cosa mostrare**:

1. Aprire Claude Code nel progetto
2. Mostrare come invocare esplicitamente un subagente:

```
Usa un subagente specializzato in testing per:
1. Analizzare l'endpoint GET /customers
2. Identificare tutti i casi da testare
3. Generare i test E2E

Il subagente deve concentrarsi SOLO sui test,
non sulla struttura del codice o altri aspetti.
```

3. Osservare come Claude:
   - Crea/invoca il subagente
   - Il subagente lavora con contesto focalizzato sui test
   - Ritorna i risultati all'agente principale

4. Mostrare che il contesto principale non è stato "inquinato" da dettagli sui test

**Testo da leggere durante la demo**:
"Invochiamo esplicitamente un subagente per i test. Guardate: gli diamo un compito specifico e lui si concentra solo su quello. Il contesto dell'agente principale resta pulito, pronto per altri task."

---

## SLIDE 7: Come Funziona Internamente

**Contenuto slide**:
```
COME FUNZIONA INTERNAMENTE

1. Agente principale riceve task complesso

2. Valuta se delegare a subagente
   └─ Task specialistico?
   └─ Contesto già saturo?
   └─ Parallelizzabile?

3. Crea subagente con:
   └─ Prompt specifico
   └─ Contesto minimale necessario
   └─ Obiettivo chiaro

4. Subagente esegue e ritorna risultato

5. Agente principale integra risultato
   └─ Verifica coerenza
   └─ Prosegue con il task
```

**Testo da leggere**:
"Internamente: l'agente valuta se delegare, crea il subagente con prompt e contesto minimali, riceve il risultato, lo integra. Il subagente non vede la storia completa della conversazione, solo ciò che serve per il suo task."

---

## DEMO 2: Subagenti Impliciti in Azione

**Cosa mostrare**:

1. Dare un task complesso che richiede più competenze:

```
Analizza l'endpoint GET /orders nel codice legacy.
Voglio sapere:
1. Quali problemi architetturali ha
2. Quali test servirebbero
3. Ci sono vulnerabilità di sicurezza?
```

2. Osservare come Claude potrebbe implicitamente:
   - Usare capacità di analisi codice
   - Valutare aspetti di testing
   - Fare security review

3. Notare come i diversi "aspetti" dell'analisi sono trattati separatamente

4. Mostrare il risultato integrato

**Testo da leggere durante la demo**:
"Diamo un task che tocca più domini: architettura, test, sicurezza. Claude gestisce internamente la complessità. Potrebbe usare subagenti impliciti per ogni aspetto, poi integrare i risultati. Noi vediamo una risposta coerente, lui ha diviso il lavoro."

---

## SLIDE 8: Parallelizzazione con Subagenti

**Contenuto slide**:
```
PARALLELIZZAZIONE CON SUBAGENTI

Esempio: Refactoring Fase 2

Sequenziale (lento):
Customers → Orders → OrderDetails
[────────][────────][────────────]
            Tempo totale: 3x

Parallelo con subagenti (veloce):
Customers  [────────]
Orders     [────────]
OrderDetails [──────]
            Tempo totale: ~1x

┌─────────────────────────────────────────┐
│  Ogni subagente lavora su un'entità     │
│  Risultati integrati alla fine          │
└─────────────────────────────────────────┘
```

**Testo da leggere**:
"Con i subagenti possiamo parallelizzare. Invece di refactorare Customers, poi Orders, poi Details in sequenza, tre subagenti lavorano contemporaneamente. Tempo ridotto drasticamente, risultati integrati alla fine."

---

## SLIDE 9: Best Practice

**Contenuto slide**:
```
BEST PRACTICE

✓ Subagenti per task specialistici e isolabili
✓ Contesto minimale: solo ciò che serve
✓ Obiettivi chiari e verificabili
✓ Agente principale verifica i risultati
✓ Usare quando il contesto si satura

✗ Subagenti per task semplici (overhead)
✗ Troppi subagenti paralleli (coordinamento)
✗ Subagenti senza obiettivo chiaro
✗ Fidarsi ciecamente dei risultati
```

**Testo da leggere**:
"Usate subagenti per task specialistici, non per cose semplici dove l'overhead non vale. Date contesto minimale e obiettivi chiari. L'agente principale deve sempre verificare i risultati prima di integrarli."

---

## SLIDE 10: Takeaway

**Contenuto slide**:
```
TAKEAWAY

✓ Subagenti risolvono il problema del contesto saturo
✓ Specializzazione: ogni agente è esperto del suo dominio
✓ Espliciti (invocati) o Impliciti (automatici)
✓ Parallelizzazione per task indipendenti
✓ L'agente principale coordina e verifica

Nel corso useremo:
Test Agent, Refactoring Agent,
Documentation Agent, Code Review Agent

Prossimo modulo: L'Analista Funzionale
```

**Testo da leggere**:
"I subagenti sono fondamentali per task complessi. Mantengono il contesto pulito, permettono specializzazione e parallelizzazione. Li useremo durante tutto il corso per le diverse fasi del refactoring. Nel prossimo modulo vediamo l'Analista Funzionale che usa Plan Mode per generare il piano di lavoro."

---

## Note di Produzione

- La demo esplicita deve mostrare chiaramente l'invocazione del subagente
- La demo implicita deve far intuire che Claude gestisce complessità internamente
- Non entrare troppo nei dettagli tecnici di implementazione
- Focus sui benefici pratici: contesto pulito, specializzazione
- Tempo: slide 5 min, demo 4 min, margine 1 min
