# Screencast 5.1: Creazione Test API End-to-End

**Durata**: max 10 minuti
**Modulo**: 5 - Sviluppo Fase 0: Test Baseline
**Scopo**: Creare la baseline di verifica sul codice legacy

---

## SLIDE 1: Titolo

**Contenuto slide**:
```
CREAZIONE TEST API END-TO-END

La rete di sicurezza del refactoring
```

**Testo da leggere**:
"Iniziamo la parte di sviluppo. Prima di toccare una riga di codice legacy, creiamo i test. Questi test catturano il comportamento attuale e diventano la nostra rete di sicurezza: se qualcosa si rompe durante il refactoring, lo sapremo."

---

## SLIDE 2: Perché Test Prima del Refactoring

**Contenuto slide**:
```
PERCHÉ TEST PRIMA

┌─────────────────────────────────────────┐
│  Senza test:                            │
│  "Il refactoring funziona?"             │
│  "...credo di sì?"                      │
│                                         │
│  Con test:                              │
│  "Il refactoring funziona?"             │
│  "Sì, 47 test passano."                 │
└─────────────────────────────────────────┘

I test trasformano "speriamo" in "sappiamo"
```

**Testo da leggere**:
"Senza test, ogni modifica è un salto nel buio. Con test, ogni modifica è verificabile. Non 'speriamo che funzioni', ma 'sappiamo che funziona perché i test passano'. Questa è la base del refactoring sicuro."

---

## SLIDE 3: Strategia di Test Baseline

**Contenuto slide**:
```
STRATEGIA DI TEST BASELINE

Test E2E sulle API:
- Chiamata HTTP reale all'endpoint
- Verifica response status
- Verifica struttura response
- Verifica dati (golden master)

NON testiamo:
- Implementazione interna
- Come funziona
- Struttura del codice

Testiamo il CONTRATTO dell'API
```

**Testo da leggere**:
"I test baseline verificano il contratto API. Chiamata HTTP, verifica risposta. Non ci interessa come funziona internamente, ci interessa che l'output sia corretto. Così possiamo cambiare tutto dentro, purché l'output resti uguale."

---

## SLIDE 4: Golden Master

**Contenuto slide**:
```
GOLDEN MASTER PATTERN

┌─────────────────────────────────────────┐
│  1. Esegui chiamata API                 │
│  2. Salva risposta come "expected"      │
│  3. Nel test, confronta con expected    │
└─────────────────────────────────────────┘

GET /customers/ALFKI → salva risposta

Test futuro:
expect(response).toEqual(savedResponse)

Se il refactoring cambia l'output,
il test fallisce
```

**Testo da leggere**:
"Il pattern Golden Master è semplice: esegui la chiamata, salva la risposta, confronta nelle esecuzioni future. Se dopo il refactoring la risposta cambia, il test fallisce. È il modo più rapido per catturare il comportamento esistente."

---

## DEMO 1: Setup Framework di Test

**Cosa mostrare**:

1. Verificare/installare Jest e Supertest:

```bash
npm install --save-dev jest supertest
```

2. Chiedere a Claude di creare la struttura:

```
Crea la struttura per i test E2E:
- Directory /tests/e2e
- File di setup che avvia l'app Express
- Helper per le chiamate HTTP
- Script npm per eseguire i test
```

3. Claude crea:
   - `/tests/e2e/setup.js`
   - `/tests/e2e/helpers.js`
   - Aggiorna `package.json` con script test

**Testo da leggere durante la demo**:
"Claude prepara l'infrastruttura di test. Directory, setup che avvia l'app, helper per le chiamate. Guardate come crea tutto seguendo le convenzioni del CLAUDE.md che abbiamo definito."

---

## SLIDE 5: Test per Endpoint

**Contenuto slide**:
```
TEST PER ENDPOINT

Per ogni endpoint testiamo:

GET /customers
└─ Lista completa
└─ Con filtri (quelli pasticciati!)
└─ Paginazione se presente

GET /customers/:id
└─ ID esistente
└─ ID non esistente

POST /customers
└─ Dati validi
└─ Dati invalidi

PUT /customers/:id
DELETE /customers/:id
└─ Stesso pattern
```

**Testo da leggere**:
"Per ogni endpoint, test completi. GET con e senza filtri, GET singolo con ID valido e invalido, POST con dati buoni e cattivi. Copriamo tutti i casi che l'API supporta, inclusi i filtri 'pasticciati' che dovremo mantenere."

---

## DEMO 2: Generare Test per Customers

**Cosa mostrare**:

1. Prompt a Claude:

```
Analizza l'endpoint GET /customers nel codice legacy.
Genera test E2E che coprono:
- Lista tutti i customers
- Filtro per city
- Filtro per country
- Combinazione di filtri
- Customer singolo per ID
- ID non esistente

Usa il pattern Golden Master: prima esegui le chiamate
per catturare le risposte attese, poi crea i test.
```

2. Claude:
   - Analizza il codice legacy
   - Identifica i filtri supportati
   - Crea i test con assertions

3. Mostrare un test generato:

```javascript
describe('GET /customers', () => {
  it('returns all customers', async () => {
    const response = await request(app).get('/customers');
    expect(response.status).toBe(200);
    expect(response.body).toHaveLength(91); // Northwind ha 91 customers
    expect(response.body[0]).toHaveProperty('CustomerID');
  });
});
```

**Testo da leggere durante la demo**:
"Claude analizza il codice legacy, identifica i filtri, crea i test. Guardate: verifica status, lunghezza risposta, struttura. Questi test catturano il comportamento esatto del sistema."

---

## SLIDE 6: Test dei Filtri Pasticciati

**Contenuto slide**:
```
TEST DEI FILTRI "PASTICCIATI"

Il legacy ha filtri aggiunti senza criterio:

GET /customers?city=London
GET /customers?country=UK
GET /customers?city=London&country=UK
GET /customers?name=A  (cerca per iniziale?)

Dobbiamo testare TUTTI questi comportamenti,
anche quelli strani.

Il refactoring deve mantenerli identici
(a meno che non siano bug da fixare)
```

**Testo da leggere**:
"I filtri del legacy sono un pasticcio. Ma sono il comportamento attuale. Li testiamo tutti, anche quelli strani. Il refactoring deve mantenerli identici, altrimenti rompiamo la compatibilità."

---

## DEMO 3: Eseguire i Test e Verificare

**Cosa mostrare**:

1. Eseguire i test:

```bash
npm test
```

2. Mostrare output: tutti i test devono passare sul codice legacy

3. Se qualche test fallisce, Claude analizza e corregge il test

4. Mostrare il report di copertura (opzionale)

**Testo da leggere durante la demo**:
"Eseguiamo i test sul codice legacy. Devono passare tutti: stiamo testando il comportamento esistente, non uno nuovo. Se un test fallisce, il test è sbagliato, non il codice. Correggiamo il test."

---

## SLIDE 7: Copertura Minima

**Contenuto slide**:
```
COPERTURA MINIMA PER REFACTORING

┌─────────────────────────────────────────┐
│  Customers                              │
│  □ GET /customers (lista)               │
│  □ GET /customers (con ogni filtro)     │
│  □ GET /customers/:id                   │
│  □ POST /customers                      │
│  □ PUT /customers/:id                   │
│  □ DELETE /customers/:id                │
├─────────────────────────────────────────┤
│  Orders                                 │
│  □ [stessi endpoint]                    │
├─────────────────────────────────────────┤
│  OrderDetails                           │
│  □ [stessi endpoint]                    │
└─────────────────────────────────────────┘

Tutti verdi prima di iniziare Fase 1
```

**Testo da leggere**:
"Prima di iniziare il refactoring vero, tutti questi test devono essere verdi. È la nostra checklist. Se manca un test, lo aggiungiamo. Se un test fallisce, capiamo perché. Solo quando tutto è verde, procediamo."

---

## SLIDE 8: Best Practice

**Contenuto slide**:
```
BEST PRACTICE

✓ Test E2E, non unit test (per ora)
✓ Coprire tutti gli endpoint
✓ Testare casi limite e filtri
✓ Golden Master per catturare comportamento
✓ Tutti verdi prima di refactoring

✗ Testare l'implementazione
✗ Saltare i casi "strani"
✗ Procedere con test rossi
✗ Modificare test e codice insieme
```

**Testo da leggere**:
"Test E2E che verificano il contratto. Copertura completa, inclusi casi strani. Tutti verdi prima di toccare il codice. E mai modificare test e codice insieme: se il test fallisce dopo un refactoring, sapete che il problema è nel refactoring."

---

## SLIDE 9: Takeaway

**Contenuto slide**:
```
TAKEAWAY

✓ Test baseline = rete di sicurezza
✓ Testiamo il contratto API, non l'implementazione
✓ Golden Master cattura comportamento esistente
✓ Tutti i filtri, anche quelli pasticciati
✓ Verde completo prima di Fase 1

Prossimo modulo: Fase 1 - Bug Fixing
```

**Testo da leggere**:
"I test baseline sono completi. Abbiamo una rete di sicurezza che ci dirà se rompiamo qualcosa. Nel prossimo modulo fixiamo i bug critici del legacy: SQL injection, filtri errati, N+1 query. Prima rendiamo il codice sicuro, poi lo refactorizziamo."

---

## Note di Produzione

- Il backend legacy deve essere funzionante per i test
- I test devono passare REALMENTE sul codice spaghetti
- Mostrare test che catturano comportamenti "strani" dei filtri
- Questo screencast è fondamentale: stabilisce la baseline
- Tempo: slide 4 min, demo 5 min, margine 1 min
