# Screencast 2.1: Analisi dei Requisiti con Claude

**Durata**: max 10 minuti
**Modulo**: 2 - Il Product Owner
**Scopo**: Mostrare come il PO può usare Claude per esplorare soluzioni

---

## SLIDE 1: Titolo

**Contenuto slide**:
```
ANALISI DEI REQUISITI CON CLAUDE

Il Product Owner e l'Agente
```

**Testo da leggere**:
"Entriamo nel vivo con il primo ruolo: il Product Owner. Vedremo come usare Claude non per scrivere codice, ma per analizzare problemi, esplorare soluzioni e prendere decisioni informate."

---

## SLIDE 2: Il Ruolo del PO nel Modello Agentico

**Contenuto slide**:
```
IL PRODUCT OWNER

Flusso: Uomo → Agente

┌─────────────────────────────────────────┐
│                                         │
│   PO definisce COSA e PERCHÉ            │
│              │                          │
│              ▼                          │
│   Claude analizza COME                  │
│              │                          │
│              ▼                          │
│   PO valuta e DECIDE                    │
│                                         │
└─────────────────────────────────────────┘

L'agente supporta, non sostituisce il giudizio
```

**Testo da leggere**:
"Il Product Owner definisce cosa serve e perché. Claude analizza come si potrebbe fare. Il PO valuta le opzioni e decide. L'agente supporta il processo decisionale ma non sostituisce il giudizio umano sulle priorità e sul valore di business."

---

## SLIDE 3: Il Nostro Caso

**Contenuto slide**:
```
IL CASO: BACKEND NORTHWIND

Situazione attuale:
- Backend Express.js monolitico
- Tutto in un unico file
- SQL inline, nessuna separazione
- Zero test
- Bug noti e nascosti

Obiettivo:
- Refactoring verso architettura pulita
- Rilasci incrementali
- Mantenere compatibilità API
```

**Testo da leggere**:
"Il nostro caso pratico: un backend Express.js volutamente disordinato. Codice monolitico, nessuna separazione delle responsabilità, zero test. L'obiettivo è refactorarlo verso un'architettura pulita con rilasci incrementali, mantenendo la compatibilità delle API."

---

## DEMO 1: Prima Analisi del Codice Legacy

**Cosa mostrare**:

1. Aprire VS Code con il progetto backend spaghetti code
2. Mostrare brevemente la struttura: un unico file app.js enorme
3. Avviare Claude Code
4. Prompt: "Analizza questo backend Express e dimmi quali sono i principali problemi architetturali che vedi"

**Claude dovrebbe identificare**:
- Mancanza di separazione delle responsabilità
- SQL inline nei route handler
- Nessuna gestione errori consistente
- Assenza di validazione input
- Duplicazione di codice
- Nessun test

**Testo da leggere durante la demo**:
"Chiediamo a Claude di analizzare il codice legacy. Non gli diciamo cosa cercare, gli chiediamo un'analisi aperta. Guardate come identifica i problemi principali senza che glieli suggeriamo."

---

## SLIDE 4: Esplorare Soluzioni

**Contenuto slide**:
```
ESPLORARE SOLUZIONI

Domande da fare a Claude:

"Quali pattern architetturali potremmo adottare?"

"Quali sono i compromessi tra Repository pattern
 e Active Record?"

"Come potremmo fare il refactoring in modo
 incrementale senza bloccare lo sviluppo?"

"Quali rischi vedi in ogni approccio?"
```

**Testo da leggere**:
"Il PO non chiede a Claude di implementare. Chiede di esplorare. Quali pattern esistono? Quali sono i compromessi? Come procedere in modo incrementale? Quali rischi ci sono? Claude diventa un consulente che presenta opzioni."

---

## DEMO 2: Esplorazione Compromessi

**Cosa mostrare**:

1. Continuare la sessione Claude
2. Prompt: "Vogliamo refactorare verso un'architettura a 3 livelli. Quali sono le opzioni per il layer di persistenza? Considera che usiamo SQLite e vogliamo mantenere il codice semplice."

**Claude dovrebbe presentare**:
- Opzione 1: Query SQL raw con helper functions
- Opzione 2: Query builder (Knex.js)
- Opzione 3: ORM completo (Sequelize, TypeORM)
- Pro e contro di ciascuna
- Raccomandazione basata sui vincoli

3. Prompt di follow-up: "Perché consigli Knex.js rispetto a un ORM completo?"

**Testo da leggere durante la demo**:
"Chiediamo a Claude di presentare le opzioni per il layer di persistenza. Nota come presenta compromessi, non solo la soluzione. Poi possiamo approfondire chiedendo il perché della raccomandazione."

---

## SLIDE 5: Validare le Assunzioni

**Contenuto slide**:
```
VALIDARE LE ASSUNZIONI

Il PO ha ipotesi. Claude le verifica.

┌─────────────────────────────────────────┐
│  PO: "Penso che i filtri sulle query    │
│       siano il problema principale"     │
│                                         │
│  Claude: "Analizziamo il codice...      │
│           In realtà il problema più     │
│           critico è [X] perché..."      │
└─────────────────────────────────────────┘

L'agente sfida le assunzioni con dati
```

**Testo da leggere**:
"Un uso potente di Claude è validare le assunzioni. Il PO pensa che il problema sia X, Claude analizza e può confermare o sfidare questa ipotesi con evidenze dal codice. Questo evita di investire tempo su problemi percepiti ma non reali."

---

## DEMO 3: Analisi Mirata

**Cosa mostrare**:

1. Continuare la sessione
2. Prompt: "Analizza gli endpoint delle Orders. Voglio capire quanto è complessa la logica di filtro e se ci sono bug potenziali nelle query"

**Claude dovrebbe**:
- Analizzare il codice specifico
- Identificare la complessità dei filtri "pasticciati"
- Trovare potenziali bug (es. SQL injection, filtri che si escludono, edge case non gestiti)
- Quantificare il problema

**Testo da leggere durante la demo**:
"Ora chiediamo un'analisi mirata sugli endpoint Orders. Claude scava nel codice, trova i problemi specifici, li quantifica. Il PO ottiene dati concreti per prioritizzare."

---

## SLIDE 6: Output per il Team

**Contenuto slide**:
```
OUTPUT DEL PO PER IL TEAM

Dopo l'analisi con Claude, il PO produce:

1. Problem Statement
   └─ Cosa non funziona e perché è importante

2. Soluzione Scelta
   └─ Pattern architetturale e motivazioni

3. Vincoli e Compromessi
   └─ Cosa abbiamo sacrificato e perché

4. Criteri di Successo
   └─ Come misuriamo se abbiamo risolto

5. Fasi di Rilascio
   └─ Incrementi consegnabili
```

**Testo da leggere**:
"Il risultato del lavoro PO-Claude non è codice, è direzione. Un problem statement chiaro, la soluzione scelta con le motivazioni, i vincoli accettati, i criteri di successo misurabili, e le fasi di rilascio. Questo diventa input per l'Analista e l'Architetto."

---

## SLIDE 7: Prompt Efficaci per il PO

**Contenuto slide**:
```
PROMPT EFFICACI

✓ "Analizza [X] e identifica i problemi principali"
✓ "Quali sono le opzioni per [Y]? Pro e contro?"
✓ "Perché consigli [Z] rispetto alle alternative?"
✓ "Quali rischi vedi in questo approccio?"
✓ "Come potremmo procedere incrementalmente?"

✗ "Implementa..."
✗ "Scrivi il codice per..."
✗ "Fai il refactoring di..."

Il PO esplora e decide, non implementa
```

**Testo da leggere**:
"I prompt del PO sono domande, non comandi. Analizza, presenta opzioni, spiega perché, identifica rischi. Non 'implementa' o 'scrivi codice'. Il PO usa Claude per pensare meglio, non per produrre."

---

## SLIDE 8: Takeaway

**Contenuto slide**:
```
TAKEAWAY

✓ Il PO usa Claude per analisi, non implementazione
✓ L'agente presenta opzioni, l'umano decide
✓ Validare le assunzioni con dati dal codice
✓ Output: direzione chiara per il team
✓ Supervisione alta: ogni decisione è umana

Prossimo screencast: Validazione e Criteri di Accettazione
```

**Testo da leggere**:
"Il PO nel modello agentico usa Claude come consulente: analizza, esplora opzioni, valida assunzioni. Ma ogni decisione resta umana. L'output non è codice ma direzione chiara per il team. Nel prossimo screencast vedremo come definire criteri di accettazione con Claude."

---

## Note di Produzione

- Le demo devono usare il backend spaghetti code reale
- Claude deve trovare problemi REALI nel codice preparato
- Mostrare il flusso conversazionale: domanda → analisi → approfondimento
- Tempo: slide 4 min, demo 5 min, margine 1 min
